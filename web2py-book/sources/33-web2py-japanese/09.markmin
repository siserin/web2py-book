## アクセス制御
``Auth``:inxx ``Access Control``:inxx ``RBAC``:inxx ``DAC``:inxx ``MAC``:inxx

web2pyには、パワフルでカスタマイズ可能なロールベースのアクセス制御メカニズム（RBAC）が含まれています。

Wikipediaでの定義を以下に示します：

「ロールベースアクセス制御（英: Role-based access control, RBAC）は、権限のあるユーザーに対してシステムアクセスを制限する手法の一種。強制アクセス制御 (MAC) や任意アクセス制御 (DAC) に対するより新しい代替手法である。RBACはロールベースのセキュリティとして参照されることもある。

RBACは、ポリシーが中立で、柔軟にアクセス制御できる技術であり、DACやMACもシミュレート可能である。逆にMACは、ロールの構造が半順序ロール階層(Partially ordered role Hierarchy)ではなく、ツリーに制限されている場合に限り、RBACをシミュレートできる。

RBAC が開発されるまで、アクセス制御のモデルとして知られていたのは MAC と DAC しかなかった。従って、モデルがMACでないなら DAC を、DAC でないならMAC であると考えられていた。90年代後半の研究では、RBAC はそのどちらにも分類されていない。

組織において、ロール（役割）は仕事上の機能のために作られる。ある操作を実行する許可（パーミッション）は、特定のロールに対して割り当てられる。従業員(またはシステムユーザー)には特定のロールが割り当てられ、そのロールの割り当てを通して特定のシステム機能を実行するパーミッションが与えられる。コンテキストベースアクセス制御 (CBAC) とは異なり、RBAC はメッセージのコンテキスト（コネクションがどこから起動されているかなど）を考慮しない。

ユーザーに対して直接パーミッションが与えられるわけではなく、ロールを通して与えられるため、各人のアクセス権の管理はユーザーへのロールの適切な割り当てに単純化される。つまり、これによりユーザーの追加やユーザーの部門の異動などの共通の操作が単純化される。

RBAC は従来の任意アクセス制御システムで用いられているアクセス制御リスト(ACL)とも異なる。ACL は低レベルのデータオブジェクトに対してパーミッションを与えるが、RBAC は組織において意味のある特定の操作に対してパーミッションを与える。例えば、一つのアクセス制御リストは特定のシステムファイルへの書き込みを許可/拒否するために用いられるが、そのファイルがどのように変更できるかは規定しない。」

web2pyには、RBACを実装したAuthクラスがあります。

Authは下記のテーブルが必要です（そして定義を行います）。
- ``auth_user`` ユーザーの名前、メールアドレス、パスワード、ステータス（登録、保留、許可、禁止）が保存される
- ``auth_group`` 多対多の構造においてユーザーに対するグループまたはロールが保存される。デフォルトでは各ユーザーは自分自身のグループに属している。しかし、１人のユーザーを複数のグループに所属させることも、各グループに複数のユーザーを含めることもできる。グループは、ロールと説明文で識別される
- ``auth_membership`` 多対多の構造においてユーザーとグループを結ぶ
- ``auth_permission`` グループとパーミッションを関連づける。パーミッションは名前（テーブルとレコードが含まれることもある）で識別される。例えば、特定のグループのメンバーは、特定のテーブルの特定のレコードの"更新"のパーミッションが与えられる
- ``auth_event`` これ以外の他のテーブルに対する変更や、RBACにより制御されたオブジェクトへのCRUDを介して成立したアクセスを記録する

原則として、ロールの名前とパーミッションの名前に制限はありません。つまり、開発者は組織内のロールやパーミッションに合わせてそれらを作成することができます。一度これらのテーブルが作成されると、web2pyは、ユーザーがログインしているかどうか、グループに属しているかどうか、および／または必要なパーミッションを持つグループの一つに属しているかどうかを確認するAPIを提供します。

web2pyは、ログイン、メンバシップ、パーミッションに基づいて任意の関数へのアクセスを制限するデコレータも提供しています。

web2pyはまた、いくつかの特別なパーミッション、すなわち、CRUDメソッド（削除、読み込み、更新、作成）に対応した名前を持つパーミッションに対応しており、デコレータを使用しなくても自動的にそのパーミッションを強制することができます。

この章では、RBACのそれぞれの構成要素を一つ一つ解説していきます。

### 認証

RBACを使用するためには、ユーザーが識別されている必要があります。これは、ユーザーが登録を行い（あるいは事前に登録されている状態で）、ログインする必要があることを意味しています。

**Auth** は複数のログイン用メソッドを提供します。デフォルトのメソッドは、ローカルの ``auth_user`` テーブルに基づいてユーザーを識別します。代わりに、サードパーティの認証システムやシングルサインオンを提供するプロバイダ（Google、PAM、LDAP、Facebook、LinkedIn、Dropbox、OpenID、OAuth、その他）に対してユーザーをログインさせることができます。

``Auth``の使用を開始するには、少なくとも以下のコードをmodelファイルに用意する必要があります。このコードはまた、web2pyの"welcome"アプリケーションで提供され、``db``接続オブジェクトを利用しています：
``
from gluon.tools import Auth
auth = Auth(db, hmac_key=Auth.get_or_create_key())
auth.define_tables()
``:code

-------
``db.auth_user`` の ``password`` フィールドには ``CRYPT`` バリデータがデフォルト指定されており、それは ``hmac_key`` と共に必要な設定です。 ``Auth.get_or_create_key()`` はアプリケーションフォルダ内の "private/auth.key" ファイルから hmac キーを読み出す機能です。もしファイルが存在しない場合は、ランダムな ``hmac_key``を生成します。また複数のアプリケーションで同じ auth（アクセス制御）データベースを共有する場合は、同一の ``hmac_key`` が使われているか確認してください。
-------

デフォルトでは web2pyはログインに email（メールアドレス） を使用します。もし代わりに usename（ユーザ名）を使用したい場合は、 ``auth.define_tables(username=True)`` と設定します。

もし複数のアプリケーションで auth データベースを共有する場合は、 ``auth.define_tables(username=True)`` のようにマイグレーションを無効に設定にしてください。

**Auth**を公開するには、次のような関数をコントローラに用意する必要があります（"default.py"にサンプルがあります）。
``
def user(): return dict(form=auth())
``:code

-------
``auth``オブジェクトと``user``関数の両方は雛形アプリケーションですでに定義されています。
-------

web2pyにはまた、適切にこの関数をレンダリングするための次のようなサンプルビュー"welcome/views/default/user.html"が含まれています：
``
{{extend 'layout.html'}}
<h2>{{=T( request.args(0).replace('_',' ').capitalize() )}}</h2>
<div id="web2py_user_form">
  {{=form}}
  {{if request.args(0)=='login':}}
    {{if not 'register' in auth.settings.actions_disabled:}}
      <br/><a href="{{=URL(args='register')}}">register</a>
    {{pass}}
    {{if not 'request_reset_password' in auth.settings.actions_disabled:}}
      <br/>
      <a href="{{=URL(args='request_reset_password')}}">lost password</a>
    {{pass}}
  {{pass}}
</div>
``:code

この関数は ``form`` を単純に表示しています。ですので、標準のフォームカスタマイズ用の構文を使ってカスタマイズすることが可能です。唯一の注意点は ``form=auth()`` によって表示されているフォームが``request.args(0)``に依存していることです。つまりデフォルトの ``auth()`` ログインフォームをカスタムログインフォームに置き換える場合、以下のビューのようにif文を利用する必要があります。
``
{{if request.args(0)=='login':}}...custom login form...{{pass}}
``:code

上記のコントローラは、複数の機能を公開しています。
``
http://.../[app]/default/user/register
http://.../[app]/default/user/login
http://.../[app]/default/user/logout
http://.../[app]/default/user/profile
http://.../[app]/default/user/change_password
http://.../[app]/default/user/verify_email
http://.../[app]/default/user/retrieve_username
http://.../[app]/default/user/request_reset_password
http://.../[app]/default/user/reset_password
http://.../[app]/default/user/impersonate
http://.../[app]/default/user/groups
http://.../[app]/default/user/not_authorized
``:code

- **register**はユーザーの登録を行います。CAPTCHAも統合されていますが、デフォルトでは無効になっています。
- **login**は事前に登録されたユーザーのログインを許可します（検証が通るか必要ない場合に、承認が通るか必要ない場合に、ブロックされていない場合に許可します）。
- **logout**は期待通りの動きをしますが、その他のメソッドのように、イベントのログを記録し、他のイベントのトリガーとして使用することもできます。
- **profile**は、ユーザーにプロファイルを編集することを許可します。プロファイルとは``auth_user``テーブルに登録された情報です。このテーブルは固定された構造を持っておらず、カスタマイズができることに注意してください。
- **change_password**は、ユーザーにフェイルセーフな方法でパスワードを変更させることができます。
- **verify_email**。Eメール検証が有効な場合、登録処理を行ったユーザーは、そのEメール情報を検証するためのリンクを含むメールを受け取ります。このリンクはこの機能を指し示します。
- **retrieve_username**。デフォルトでは、 **Auth**はEメールとパスワードを使用してログインしますが、電子メールの代わりにユーザー名を使うこともできます。後者のケースでは、もしユーザーがユーザー名を忘れた場合、``retrieve_username``メソッドによって、ユーザーにメールアドレスを入力させ、そのアドレスに送られたメールからユーザー名を取得することが可能になります。
- **request_reset_password**。このメソッドでは、自分のパスワードを忘れてしまったユーザーが新しいパスワードを要求できます。ユーザーは、**reset_password**を指し示す確認メールを受け取ることになります。
- **impersonate**は、あるユーザーを別の"偽装ユーザー"にすることができます。これは、デバッグと、サポートにとって重要な機能です。``request.args[0]``が偽装されたユーザーIDになります。このメソッドは、``has_permission('impersonate', db_auth_user, user_id)``として指定されたユーザーでログインした時のみ有効となります。
- **groups**は、現在ログオンしているユーザーが所属しているグループが一覧表示されます。
- **not_authorized**は、ユーザーが権限のないページを表示しようとした時に、エラーメッセージを表示します。
- **navbar**は、ログインやユーザー登録リンクなどのバー（ナビゲーションバー）を生成するヘルパーです。

Logout、profile、change_password、impersonate、groupsは、ログインしている必要があります。

デフォルトではこれらはすべて公開されますが、それらの機能の一部のみにアクセスを制限することも可能です。

上記のすべてのメソッドは、 **Auth** のサブクラスを作成することで、拡張したり置き換えたりすることが可能です。

また次の例のように、すべてのメソッドは別々の機能として使用することも可能です。

``
def mylogin(): return dict(form=auth.login())
def myregister(): return dict(form=auth.register())
def myprofile(): return dict(form=auth.profile())
...
``

ログインした訪問者のみ関数にアクセスできるよう制限するためには、以下のサンプルのように関数にデコレータを指定します。
``
@auth.requires_login()
def hello():
    return dict(message='hello %(first_name)s' % auth.user)
``:code

全ての関数はデコレータを指定できます。公開されているものだけではありません。もちろんこれは、アクセスコントロールの非常に単純な例です。より複雑な例については後述します。
``auth.user``:inxx ``auth.user_id``:inxx

-----
``auth.user`` は、現在ログインしているユーザーに該当する ``db.auth_user`` のレコードのコピーか、 ``None`` を格納しています。またauth.user_idは ``auth.user.id`` と同じ値（すなわち、現在ログインしているユーザーのID）か ``None`` になります。
-----

#### 登録の制限

訪問者が登録を行うことはできるが、管理者によって承認されるまでログインできないようにする場合：
``
auth.settings.registration_requires_approval = True
``:code

appadminインターフェイスを介して、登録を承認することができます。 ``auth_user`` テーブルを見てください。保留中の登録情報は、 ``registration_key`` フィールドに "pending" が設定されています。登録を承認するには、このフィールドを空白に設定します。

appadminインターフェイスを介して、ユーザーをログインできないようにすることもできます。``auth_user``から該当のユーザーを見つけて ``registration_key`` を "blocked" に設定します。 "blocked" となったユーザーは、ログインができません。ただし、ログインしていないユーザーからのログインを防ぐことははできますが、既にログインしているユーザーを強制的にログアウトさせることはできません。"disabled"を"blocked"の代わりに使用することもできます。動きは全く同じです。

また以下のステートメントを使用して完全に "登録" ページへのアクセスをブロックすることができます：
``
auth.settings.actions_disabled.append('register')
``:code

訪問者が登録し登録完了後に、自動ログインを行うことも可能です。その場合に確認用メールを送信し、メールを使った確認を完了しない限り、ログアウト後のログインを禁止するには次の設定を行います。

``
auth.settings.registration_requires_approval = True
auth.settings.login_after_registration = True
``:code

**Auth**の他のメソッドも同じ方法で制限することができます。

#### OpenID, Facebook などとの統合
``Janrain``:inxx ``OpenID``:inxx ``Facebook``:inxx ``LinkedIn``:inxx ``Google``:inxx ``MySpace``:inxx ``Flickr``:inxx

web2pyのロールベースのアクセス制御を使用して、OpenID、Facebook、LinkedIn、Google、Dropbox、MySpace、Flickr、などの外部サービスによる認証ができます。
最も簡単な方法は、Janrain Engage（旧RPX）（Janrain.com）を使用することです。

Dropboxはログインしたユーザへの、ストレジサービスプロバイダです。14章（その他のレシピ）で、ログイン以外のケースについても特別に触れます。

Janrain Engageはミドルウェアの認証を提供するサービスです。Janrain.comへの登録、そして使用するドメイン（あなたのアプリケーションの名前）と利用するURLの登録を行うことができます。そしてAPIキーが提供されます。

では、あなたのweb2pyアプリケーションのモデルを編集して、以下の行を ``auth`` オブジェクトの定義より後ろに追加してください：

``
from gluon.contrib.login_methods.rpx_account import RPXAccount
auth.settings.actions_disabled=['register','change_password','request_reset_password']
auth.settings.login_form = RPXAccount(request,
    api_key='...',
    domain='...',
    url = "http://localhost:8000/%s/default/user/login" % request.application)
``:code

最初の行は新しいログインメソッドをインポートしています。2行目は、ローカルユーザーの登録を無効にしています。3行目はweb2pyに対してRPXのログインメソッドを使用するように指示しています。Janrain.comによって提供される独自の ``api_key`` 、登録する際に選択したドメイン、アプリケーションのログインページの ``url`` を設定する必要があります

[[image @///image/en6900.png center 300px]]

新しいユーザーが最初にログインした時に、web2pyはそのユーザーに関連づけられた新規の ``db.auth_user`` のレコードを作成します。``registration_id``フィールドが、ユーザーを一意に識別するIDとして設定されます。ほとんどの認証方法は、ユーザー名、電子メール、名前と名字を提供しますが、必ず提供されるとは限りません。どのフィールドを提供しているかは、ユーザーによって選択されたloginメソッドに依存します。もし同じユーザーが異なる認証のメカニズムを使ってログインした場合（例えば、OpenIDでログインしたあとにFacebookでログインし直した）Janrainは、それらを同じユーザーとしては認識せず、それぞれの ``registration_id`` を発行します。

Janrainによって提供されるデータと``db.auth_user``に保存されるデータとのマッピングは、カスタマイズすることができます。ここではFacebookを例として示します：
``
auth.settings.login_form.mappings.Facebook = lambda profile:\
            dict(registration_id = profile["identifier"],
                 username = profile["preferredUsername"],
                 email = profile["email"],
                 first_name = profile["name"]["givenName"],
                 last_name = profile["name"]["familyName"])
``:code

ディクショナリ内のキーは、 ``db.auth_user`` のフィールドです。そして値は、Janrainによって提供されるプロファイルオブジェクトに存在するデータエントリです。後者の詳細については、オンラインJanrainのマニュアルをご覧ください。

Janrainはまた、ユーザーのログインに関する統計情報を保持します。

このログインフォームは、web2pyのロールベースのアクセス制御と完全に統合されており、グループの作成、ユーザーのグループへの割り当て、権限の割り当て、ユーザーのブロック等を行うことができます。

-----
JanrainのフリーBasicサービスは、年間2500ユニークユーザーのサインインが可能です。さらに多くのユーザーの利用には、有料サービスのどれかにアップグレードする必要があります。

Janrainではなく、他のログインメソッド（LDAP、PAM、Google、OpenID、OAuth/Facebook、LinkedIn、など）を必要とする場合は、それを利用することもできます。そのためのAPIは、本章の後半で記載します。
-----

#### CAPTCHA と reCAPTCHA

``CAPTCHA``:inxx ``reCAPTCHA``:inxx ``PIL``:inxx
スパマーやボットによるあなたのサイトへの不要な登録を避けるため、登録用のCAPTHCAが必要になるときがあります。web2pyはすぐ使える reCAPTCHA ``recaptcha``:cite をサポートしています。reCAPTCHAは、よく設計されていて、無料で、利便性がよく（訪問者が簡単に単語を読むことができる）、簡単に導入できて、その他のサードパーティー製のライブラリを必要としないからです。

以下は、reCPATCHAを使う時に必要となることです。
- reCPATCHA``recaptcha``:cite に登録を行い、登録アカウント用のパブリックキー, プライベートキーを入手してください。これらは単に二つの文字列です。
- 次のコードを``auth``オブジェクトを定義した後にモデルに追加してください。
``
from gluon.tools import Recaptcha
auth.settings.captcha = Recaptcha(request,
    'PUBLIC_KEY', 'PRIVATE_KEY')
``:code

reCAPTCHAは、'localhost'や'127.0.0.1'というアドレスのサイトにアクセスした場合はうまく動かないかもしれません。外部に公開されたサイトでのみ動作するように登録されているからです。

``Recaptcha``のコンストラクタは、いくつかの任意の引数をとります。
``
Recaptcha(..., use_ssl=True, error_message='invalid', label='Verify:', options='')
``:code

``use_ssl=False`` が初期値となっています。

``options`` は設定用文字列などです。例 ``options="theme:'white', lang:'fr'"``

詳細: [[reCAPTCHA http://www.google.com/recaptcha]]``recaptchagoogle``:cite  と [[customizing http://code.google.com/apis/recaptcha/docs/customization.html]]``recaptchacustomizing``:cite  .

もし、reCAPTCHAを必要としない場合は、"gluon/tools.py"の中の``Recaptcha``クラスを見てください。他のCAPTCHAシステムを利用するのも簡単です。

注意 ``Recaptcha`` は ``DIV`` を拡張したヘルパーがあります。これは ``reCaptcha`` や他のサービスを使うことのできる、バリデートのダミーのフィールドを生成します。これは定義し使用したフォームを含む、どのフォームでも使うことができます。

``
form = FORM(INPUT(...),Recaptcha(...),INPUT(_type='submit'))
``:code

SQLFORMの全てのタイプにも挿入可能です。
``
form = SQLFORM(...) or SQLFORM.factory(...)
form.element('table').insert(-1,TR('',Recaptcha(...),''))
``:code

#### ``Auth`` のカスタマイズ

以下の呼び出しについて
``
auth.define_tables()
``:code

この呼び出しは、まだ登録されていない **Auth** テーブルの定義を行います。つまり、独自の ``auth_user`` テーブルを定義することができるのです。

auth のカスタマイズはいくつもの方法があります。最も簡単な方法は、拡張フィールドを追加することです。

``
## after auth = Auth(db)
auth.settings.extra_fields['auth_user']= [
  Field('address'),
  Field('city'),
  Field('zip'),
  Field('phone')]
## before auth.define_tables(username=True)
``

"auth_user" テーブルだけでなく拡張フィールドは、他の "auth_" テーブルでも定義することが可能です。
拡張フィールドを使う方法は、内部メカニズムを停止させることがないため、推奨している方法です。

他に（これはエキスパート用です！）、auth テーブル自身を定義する方法です。もしテーブルを ``auth.define_tables()`` の前に定義すれば、デフォルトテーブルの代わりに使われます。以下方法を示します。

``
## after auth = Auth(db)
db.define_table(
    auth.settings.table_user_name,
    Field('first_name', length=128, default=''),
    Field('last_name', length=128, default=''),
    Field('email', length=128, default='', unique=True), # required
    Field('password', 'password', length=512,            # required
          readable=False, label='Password'),
    Field('address'),
    Field('city'),
    Field('zip'),
    Field('phone'),
    Field('registration_key', length=512,                # required
          writable=False, readable=False, default=''),
    Field('reset_password_key', length=512,              # required
          writable=False, readable=False, default=''),
    Field('registration_id', length=512,                 # required
          writable=False, readable=False, default=''))

## do not forget validators
custom_auth_table = db[auth.settings.table_user_name] # get the custom_auth_table
custom_auth_table.first_name.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.last_name.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.password.requires = [IS_STRONG(), CRYPT()]
custom_auth_table.email.requires = [
  IS_EMAIL(error_message=auth.messages.invalid_email),
  IS_NOT_IN_DB(db, custom_auth_table.email)]

auth.settings.table_user = custom_auth_table # tell auth to use custom_auth_table

## before auth.define_tables()
``:code

フィールドはいくつでも追加することは可能です。またバリデータも変更可能です。しかし、このサンプルにある "required" のコメントが入ったフィールドは削除することはできません。

"password", "registration_key", "reset_password_key", "registration_id"フィールドを``readable=False``と ``writable=False``に設定することは重要です。訪問者が不正にこれらの値を改竄できるようなことがあってはならないからです。

"username"というフィールドを追加した場合、これを"email"フィールドの代わりにログイン時に利用することができます。この場合、以下のようなバリデータを追加する必要があります。
``
auth_table.username.requires = IS_NOT_IN_DB(db, auth_table.username)
``:code

#### ``Auth`` テーブルの名前変更

``Auth``テーブルの名前は、次のように定義されています。
``
auth.settings.table_user_name = 'auth_user'
auth.settings.table_group_name = 'auth_group'
auth.settings.table_membership_name = 'auth_membership'
auth.settings.table_permission_name = 'auth_permission'
auth.settings.table_event_name = 'auth_event'
``:code

これらの名前は ``auth`` オブジェクトの定義を行ってから Auth テーブルの定義を行うまでの間で再定義することにより変更できます。以下は設定例です。 
``
auth = Auth(db)
auth.settings.table_user_name = 'person'
#...
auth.define_tables()
``:code

テーブルは次の属性値により、その名前とは無関係に参照することが可能です。
``
auth.settings.table_user
auth.settings.table_group
auth.settings.table_membership
auth.settings.table_permission
auth.settings.table_event
``:code

#### その他のログイン方式とログインフォーム
``LDAP``:inxx ``PAM``:inxx

Authは多数のログイン方式の提供と、新しいログイン方式作成のためのフックを提供します。サポートしている各ログイン方式は、次のフォルダ内の各ファイルに対応しています。
``
gluon/contrib/login_methods/
``:code

各ログイン方式に関しては、ファイル自身に記述された説明を参照してください。ここではいくつかの例だけを説明します。

まず、以下の二つの異なるタイプのログイン方式の違いを理解する必要があります。
- web2pyのログインフォームを使ったログイン方式（ただし認証は web2py の外で行われる）。例：LDAP。
- 外部のシングルサインオン用フォームを必要とするログイン方式（例：GoogleやFacebook）

後者の場合は、web2pyはログイン用の認証情報を取得せず、サービスプロバイダから発行されたログイン用のトークンのみを取得します。このトークンは、 ``db.auth_user.registration_id``に保存されます。

それでは、最初の例を見てみましょう。

##### ベーシック認証

認証サービスがあります。例えば次のURLが

``
https://basic.example.com
``:code

ベーシック認証を実施するようにします。これはこのサーバが以下のようなヘッダ情報を持つフォームの、HTTPリクエストを受けとることを意味します。

``
GET /index.html HTTP/1.0
Host: basic.example.com
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
``:code

後半の文字列は base64 でエンコーディングされた、ユーザー名:パスワード の文字列です。このサービスはユーザーが認証に成功した場合は 200 OK を、それ以外の場合は 400, 401, 402, 403 あるいは 404 を返します。

``Auth``標準のログインフォームを使用しユーザー名とパスワードを入力させ、そのサービスに対しての認証をしたいとします。この場合は、単にアプリケーションに以下のコードを挿入するだけで十分です。
``
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods.append(
    basic_auth('https://basic.example.com'))
``:code

``auth.settings.login_methods`` は、順番に実行される認証方式のリストです。
デフォルでは以下のように設定されています。
``
auth.settings.login_methods = [auth]
``:code

代替の認証方式がリストに追加された場合（例 ``basic_auth`` ）、**Auth** はまず ``auth_user`` に登録された情報に基づいて訪問者の認証を試みます。認証に失敗した場合は、リストに載っている次の方式で認証を試みます。もし認証に成功しなおかつ ``auth.settings.login_methods[0]==auth`` となるとき、 **Auth** は以下の処理を実行します：
- ``auth_user`` にユーザーが存在しない場合、新しいユーザーが作成され、 username/email と password を保存します。
- ``auth_user`` にユーザーが存在するが、入力された新しいパスワードが登録されたパスワードと一致しない場合、登録パスワードを新しいものに置き換えます(特に指定しない限り、パスワードは常にハッシュ化されたものを保存します)。

新しいパスワードを``auth_user``に保存したくない場合は、ログイン方法の順番を変更すれば十分です。もしくは、``auth``をリストから削除します。以下は設定例です。
``
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods = \
    [basic_auth('https://basic.example.com')]
``:code

ここで記載する他のログイン方法についても同様です。

##### SMTP と Gmail
``SMTP``:inxx ``Gmail``:inxx

##### SMTP and Gmail
``SMTP``:inxx ``Gmail``:inxx

ログイン用の認証情報をリモートのSMTPサーバ（例えばGmail）を用いて検証することができます。すなわちユーザーの提供する email とパスワードが、Gmail の SMTP サーバ( ``smtp.gmail.com:587`` )に正常にアクセスできるものであればユーザーをログインさせることができます。これに必要なのは以下のコードだけです。
``
from gluon.contrib.login_methods.email_auth import email_auth
auth.settings.login_methods.append(
    email_auth("smtp.gmail.com:587", "@gmail.com"))
``:code

``email_auth`` の最初の引数は、SMTPサーバの "address:port" です。二つ目の引数はメールのドメインです。

これは、``TLS`` 認証を必要とするSMTPサーバに対しても動作します。``TLS``:inxx

##### PAM
``PAM``:inxx

Pluggable Authentication Modules(PAM)を使った認証は、前のケースと同様に機能します。これにより、オペレーティングシステムのアカウントを用いてユーザーの認証ができるようになります。
``
from gluon.contrib.login_methods.pam_auth import pam_auth
auth.settings.login_methods.append(pam_auth())
``:code

##### LDAP
``LDAP``:inxx

LDAPを使った認証は、前のケースと全く同様に機能します。

LDAPを MS Active Directoryとともに使用する方法です。：``Active Directory``:inxx
``
from gluon.contrib.login_methods.ldap_auth import ldap_auth
auth.settings.login_methods.append(ldap_auth(mode='ad',
   server='my.domain.controller',
   base_dn='ou=Users,dc=domain,dc=com'))
``:code

LDAPをLotus NotesとDominoとともに使用する方法です。：``Lotus Notes``:inxx ``Domino``:inxx
``
auth.settings.login_methods.append(ldap_auth(mode='domino',
   server='my.domino.server'))
``:code

LDAPをOpenLDAP（UIDによる）とともに使用する方法です。:``OpenLDAP``:inxx
``
auth.settings.login_methods.append(ldap_auth(server='my.ldap.server',
   base_dn='ou=Users,dc=domain,dc=com'))
``:code

LDAPをOpenLDAP（CNによる）とともに方法です。
``
auth.settings.login_methods.append(ldap_auth(mode='cn',
   server='my.ldap.server', base_dn='ou=Users,dc=domain,dc=com'))
``:code

##### Google App Engine
``GAE login``:inxx

Google App Engine上で動作しているアプリケーションでGoogleによる認証を行う場合には、web2pyのログインフォームによる認証は行わず、Googleのログインページにリダイレクトを行い、そして成功したら元のページに戻るようにします。前述の例とは動作が異なるため、APIは少し異なります。

``
from gluon.contrib.login_methods.gae_google_login import GaeGoogleAccount
auth.settings.login_form = GaeGoogleAccount()
``:code

##### OpenID
``OpenID``:inxx

（OpenIDのサポートがある）Janrainの組み込みについて説明しましたが、これが最も簡単なOpenIDを使う方法です。しかし、サードパーティー製のサービスに頼るのではなく、OpenIDプロバイダにその利用者（あなたのアプリケーション）から直接アクセスしたいこともあります。

設定例です。

``
from gluon.contrib.login_methods.openid_auth import OpenIDAuth
auth.settings.login_form = OpenIDAuth(auth)
``:code

``OpenIDAuth``は''python-openid''モジュールを別途インストールする必要があります。内部では、このログイン方式は次のようなテーブルを定義します。

``
db.define_table('alt_logins',
    Field('username', length=512, default=''),
    Field('type', length =128, default='openid', readable=False),
    Field('user', self.table_user, readable=False))
``:code

このテーブルには、各ユーザーのopenidのユーザー名が保存されます。現在ログインしているユーザーのopenidを表示したい場合は、次のようにします。

``
{{=auth.settings.login_form.list_user_openids()}}
``:code

##### OAuth2.0 と Facebook
``OAuth``:inxx ``Facebook``:inxx

（Facebookのサポートがある）Janrainの組み込みについて説明しましたが、サードパーティー製のサービスに頼るのではなく、OAuth2.0プロバイダ（例えばFacebook）にその利用者（あなたの作成するアプリケーション）から直接アクセスしたいこともあります。方法は以下の通りです。

``
from gluon.contrib.login_methods.oauth20_account import OAuthAccount
auth.settings.login_form=OAuthAccount(YOUR_CLIENT_ID,YOUR_CLIENT_SECRET)
``:code

自分のアプリケーションではなく、特定の Facebook アプリケーションのAPIにアクセスするために Facebook OAuth2.0 を用いる場合は、少し複雑になります。Facebook Graph APIにアクセスする例を示します。

初めに、 [[Facebook Python SDK https://github.com/facebook/python-sdk]] をインストールする必要があります。

そして、モデルに以下のコードを追加します。

``
## import required modules
from facebook import GraphAPI
from gluon.contrib.login_methods.oauth20_account import OAuthAccount
## extend the OAUthAccount class
class FaceBookAccount(OAuthAccount):
    """OAuth impl for Facebook"""
    AUTH_URL="https://graph.facebook.com/oauth/authorize"
    TOKEN_URL="https://graph.facebook.com/oauth/access_token"
    def __init__(self, g):
        OAuthAccount.__init__(self, g,
                              YOUR_CLIENT_ID,
                              YOUR_CLIENT_SECRET,
                              self.AUTH_URL,
                              self.TOKEN_URL)
        self.graph = None
    # override function that fetches user info
    def get_user(self):
        "Returns the user using the Graph API"
        if not self.accessToken():
            return None
        if not self.graph:
            self.graph = GraphAPI((self.accessToken()))
        try:
            user = self.graph.get_object("me")
            return dict(first_name = user['first_name'],
                        last_name = user['last_name'],
                        username = user['id'])
        except GraphAPIError:
            self.session.token = None
            self.graph = None
            return None
## use the above class to build a new login form
auth.settings.login_form=FaceBookAccount()
``:code

##### LinkedIn
``LinkedIn``:inxx

（LinkedInのサポートがある）Janrainの組み込みについて説明しましたが、これが最も簡単なOAuthを使った方法です。しかし、サードパーティー製のサービスに頼るのではなく、Janrainプロバイダが提供するよりも多くの情報を得たいためにLinkedInに直接アクセスしたい場合もあります。

方法は以下の通りです。

``
from gluon.contrib.login_methods.linkedin_account import LinkedInAccount
auth.settings.login_form=LinkedInAccount(request,KEY,SECRET,RETURN_URL)
``:code

``LinkedInAccount``は"python-linkedin" モジュールを別途インストールする必要があります。

##### X509

x509証明書と証明書から取得した認証をページに渡すことによって、ログインがすることが可能です。これには ``M2Crypto`` を次のサイトからインストールする必要があります。

``
http://chandlerproject.org/bin/view/Projects/MeTooCrypto
``

M2Cryption がインストールされたら、使用可能です。

``
from gluon.contrib.login_methods.x509_auth import X509Account
auth.settings.actions_disabled=['register','change_password','request_reset_password']
auth.settings.login_form = X509Account()
``:code

web2py内部でx509証明書を渡して認証します。どのようにするかはブラウザによって違いますがWebサービス用の証明書使用する場合がほとんどです。次の例は ``cURL`` を使って認証を試したものです。

``
curl -d "firstName=John&lastName=Smith" -G -v --key private.key \
     --cert  server.crt https://example/app/default/user/profile
``

この機能は Rocket（web2py組み込みの Webサーバ）では、すぐ使えます。しかし違う Webサーバを使用する場合は、サーバ側で何らかの特別な設定が必要です。証明書をローカルホスト上のどこに置くか、クライアントから来る証明書を検証する必要があるかなど、個別に Webサーバに指定する必要があります。これらは Webサーバに依存するため、説明は省略します。

##### Multiple login フォーム

ログイン方法の中には、login_formを変更するものとしないものがあります。変更する場合は、他と共存することができないかもしれません。ただし、同じページに複数のログインフォームを表示することで共存させることができます。web2pyは、そのための方法を提供しています。ここに、通常のログイン(auth)とRPXログイン(janrain.com)を共存させる例を示します。

``
from gluon.contrib.login_methods.extended_login_form import ExtendedLoginForm
other_form = RPXAccount(request, api_key='...', domain='...', url='...')
auth.settings.login_form = ExtendedLoginForm(request,
    auth, other_form, signals=['token'])
``:code

もしシグナルが設定され、リクエストに含まれるパラメータがいずれかのシグナルにマッチした場合、代わりに ``other_form.login_form`` への呼び出しを返します。``other_form``は、個別な状態をハンドルできます。例えば ``other_form.login_form`` 内での、複数のステップによる OpenIDログインです。

そうでない場合は、``other_form``と共に通常のログインフォームが表示されます。

### ``Mail`` と ``Auth``

メーラを次のように設定できます。

``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
``

もしくは簡単に ``auth`` を使い、メールプロバイダの設定ができます。

``
mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
``

mail.settingsを使用するSMTPサーバの正しいパラメータに置き換える必要があります。``mail.settings.login=False`` と設定すると、SMTPサーバは認証を要求しません。

web2py API のメールとメール設定に関しては、8章でさらに触れています。ここでは ``Mail`` と ``Auth`` の相互作用に関して、限定的に説明します。

``Auth`` でのメールによる確認は、デフォルトでは無効になっています。
メールを有効にするには、モデルの ``auth`` 定義の後に次のコードを追加します。

``
auth.settings.registration_requires_verification = False
auth.settings.registration_requires_approval = False
auth.settings.reset_password_requires_verification = True
auth.messages.verify_email = 'Click on the link http://' + \
    request.env.http_host + \
    URL(r=request,c='default',f='user',args=['verify_email']) + \
    '/%(key)s to verify your email'
auth.messages.reset_password = 'Click on the link http://' + \
    request.env.http_host + \
    URL(r=request,c='default',f='user',args=['reset_password']) + \
    '/%(key)s to reset your password'
``:code

次の文字列は、
``
'Click on the link ...'
``:code

``auth.messages.verify_email`` にありますが、 URLの設定を ``verify_email`` が動く正しいURLに変更する必要があります。なぜなら、web2pyはプロキシの背後にインストールされているかもしれず、自身の公開URLを確実に決定することができないからです。

### 認可

新しいユーザーが登録されると、そのユーザーを含む新しいグループが作成されます。新しいユーザーのロールは、慣例的に"user_[id]"となります。ここで、[id]の部分は新しいユーザーのidです。自動的にグループを作成したくない場合は、以下のようにします。
``
auth.settings.create_user_groups = False
``:code

ただし、この設定は推奨していません。

ユーザーはグループのメンバーシップを保持します。それぞれのグループは名前かロール名で特定されます。グループはパーミッションを保持します。従って、ユーザーも所属するグループのパーミッションを保持するになります。

グループの作成とグループへのメンバーシップとパーミッションの割り当ては、**appadmin**を利用するか、以下のメソッドを使ってプログラム的に行うことができます。

``
auth.add_group('role', 'description')
``:code

``
auth.add_group('role', 'description')
``:code

これは、新しく作成したグループのidを返します。

``
auth.del_group(group_id)
``:code

これは、``group_id``を持つグループを削除します。

``
auth.del_group(auth.id_group('user_7'))
``:code

これは、 "user_7"のロールを持つグループ、つまり７番のユーザーに一意に関連付けられたグループを削除します。

``
auth.user_group(user_id)
``:code

これは、``user_id``で特定されるユーザーに一意に関連付けられたグループのidを返します。

``
auth.add_membership(group_id, user_id)
``:code

これは、 ``group_id`` グループへのメンバーシップを ``user_id`` に与えます。 ``user_id`` が指定されない場合、現在のログインユーザーのidが使用されます。

``
auth.del_membership(group_id, user_id)
``:code

これは、 ``group_id`` グループへの ``user_id`` のメンバーシップを取り消します。 ``user_id`` が指定されない場合、現在のログインユーザーのidが使用されます。

``
auth.has_membership(group_id, user_id, role)
``:code

これは ``user_id`` が、 ``group_id`` グループか、もしくは特定のロールを持つグループに属するメンバーシップがどうかを確認します。 ``group_id`` と ``role`` の両方ではなく、どちらかを指定してください。 ``user_id`` が指定されない場合、現在のログインユーザーのidが使用されます。

``
auth.add_permission(group_id, 'name', 'object', record_id)
``:code

これは、（ユーザー定義の）"object"というオブジェクトに対する（ユーーザ定義の）"name"というパーミンションを、``group_id`` グループのメンバーに与えます。"object"がテーブル名の場合、``record_id`` がゼロならばテーブル全体に対して、``record_id`` がゼロより大きい場合は特定のレコードにだけにパーミッションを与えます。パーミッションをテーブルに与えた場合は、('create', 'read', 'update', 'delete', 'select') の中からパーミッション名を利用するのが一般的です。CRUDはこれらのパーミッション名を元に、認可を制御します。

``group_id`` の指定がゼロの場合、現在のログインユーザーに関連付けられているユニークなグループが使用されます。

また、 ``auth.id_group(role="...")`` を使用すると、指定したロール名からグループidを取得できます。 ``id_group``:inxx

``
auth.del_permission(group_id, 'name', 'object', record_id)
``:code

これは、パーミッションを取り消します。

``
auth.has_permission('name', 'object', record_id, user_id)
``:code

これは、``user_id`` で特定されるユーザーが、指定したパーミッションを持つグループのメンバーかどうかを確認します。

``
rows = db(auth.accessible_query('read', db.mytable, user_id))\
    .select(db.mytable.ALL)
``:code

これは、"mytable"テーブルの中の ``user_id`` ユーザーが"read"パーミッションを持つ行を、全て返します。``user_id`` の指定がない場合、現在のログインユーザーのidが使用されます。``accessible_query(...)`` は他のクエリと組み合わて、より複雑なものを作ることができます。``accessible_query(...)`` はJOINを使う唯一の **Auth** のメソッドです。そのため、Google App Engineでは動作しません。

以下はコード例で使用する定義です。
``
>>> from gluon.tools import Auth
>>> auth = Auth(db)
>>> auth.define_tables()
>>> secrets = db.define_table('document', Field('body'))
>>> james_bond = db.auth_user.insert(first_name='James',
                                     last_name='Bond')
``:code

認可に関するコード例です。
``
>>> doc_id = db.document.insert(body = 'top secret')
>>> agents = auth.add_group(role = 'Secret Agent')
>>> auth.add_membership(agents, james_bond)
>>> auth.add_permission(agents, 'read', secrets)
>>> print auth.has_permission('read', secrets, doc_id, james_bond)
True
>>> print auth.has_permission('update', secrets, doc_id, james_bond)
False
``:code

#### デコレータ

パーミッションを確認する最も一般的な方法は、上記のメソッドを明示的に呼び出すのではありません。関数にデコレータを指定し、ログインしている訪問者に対してパーミッションのチェックをするようにします。以下、いくつか例を示します。
``
def function_one():
    return 'this is a public function'

@auth.requires_login()
def function_two():
    return 'this requires login'

@auth.requires_membership('agents')
def function_three():
    return 'you are a secret agent'

@auth.requires_permission('read', secrets)
def function_four():
    return 'you can read secret documents'

@auth.requires_permission('delete', 'any file')
def function_five():
    import os
    for file in os.listdir('./'):
        os.unlink(file)
    return 'all files deleted'

@auth.requires(auth.user_id==1 or request.client=='127.0.0.1', requires_login=True)
def function_six():
    return 'you can read secret documents'

@auth.requires_permission('add', 'number')
def add(a, b):
    return a + b

def function_seven():
    return add(3, 4)
``:code

``@auth.requires(condition)`` の condition引数は、呼び出し可能にすることができます。また、``@auth.requires`` は、デフォルト値が ``True`` のオプションの引数 ``requires_login`` を取ります。もし False を指定した場合、true / false のようにcondition引数を評価する前に、ログインを要求しません。condition引数はブール値か、ブール値を返す関数を指定します。

最初の一つ以外の全ての関数は、訪問者がパーミッションを持っているか持っていないかによってアクセスを制限することを、注意してください。

訪問者がログインしていない場合、パーミッションの確認はできません。このためログインページにリダイレクトされ、ログイン後にパーミッションが必要なページに戻ります。

#### 権限要求の組み合わせ

権限要求を組み合わせることが必要になる場合があります。これは真か偽かの条件を一つの引数で設定する、汎用的な ``requires``デコレータによって行うことができます。例えば、agentsにアクセス権限を与えるが、火曜日のみにする場合は次のようにします：
``
@auth.requires(auth.has_membership(group_id=agents) \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
``:code

次の書き方もできます。
``
@auth.requires(auth.has_membership(role='Secret Agent') \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
``:code

#### 権限とCRUD

デコレータと and/or を使って明示的なチェックすることは、アクセス制御の一つの実装方法です。

もう一つの実装方法は、データベースアクセスに常にCRUDを使う( ``SQLFORM`` ではなく)ことによって、データベーステーブルやレコードに対するアクセス制御をCRUDから実行することです。これは次の命令文を用いて、``Auth`` とCRUDを紐づけることで実施します。
``
crud.settings.auth = auth
``:code

これは、訪問者が明示的なアクセス権を持ってログインしていない限り、いかなるCRUD関数へのアクセスも防ぎます。例えば、訪問者はコメントを投稿できるが、自分自身のコメントしか更新できないようにするには、次のようにします（crud、authおよびdb.commentが定義されているものとします）：

``
def give_create_permission(form):
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'read', db.comment)
    auth.add_permission(group_id, 'create', db.comment)
    auth.add_permission(group_id, 'select', db.comment)

auth.settings.register_onaccept = give_create_permission
crud.settings.auth = auth

def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   comments = db(db.comment).select()
   return dict(form=form, comments=comments)
``:code

これにより訪問者がログインし明示的なアクセス権を持たない限り、どのCRUD関数もアクセスできなくなります。例えば、コメントを作成できるが、自分が作成したコメントしか更新できません（crud、auth、db.commentは宣言済みとする）:

``
def give_create_permission(form):
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'read', db.comment)
    auth.add_permission(group_id, 'create', db.comment)
    auth.add_permission(group_id, 'select', db.comment)

auth.settings.register_onaccept = give_create_permission
crud.settings.auth = auth

def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   comments = db(db.comment).select()
   return dict(form=form, comments=comments)
``:code

（'read'権限を持つ)特定のレコードを選択することもできます。
``
def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   query = auth.accessible_query('read', db.comment, auth.user.id)
   comments = db(query).select(db.comment.ALL)
   return dict(form=form, comments=comments)
``:code

以下で有効なパーミッション名は

``
crud.settings.auth = auth
``:code

are "read", "create", "update", "delete", "select", "impersonate" になります。

#### 認可とダウンロード

デコレータや``crud.settings.auth``を使用しても、通常のダウンロード関数を使ったファイルダウンロードの認可は実施されません。
``
def download(): return response.download(request, db)
``:code

ファイルダウンロードでの認可を実施する場合、どの"upload"フィールドがアクセス制御が必要なファイルと関連があるかを、明示的に宣言しなければなりません。以下、設定例です。
``
db.define_table('dog',
   Field('small_image', 'upload'),
   Field('large_image', 'upload'))

db.dog.large_image.authorization = lambda record: \
   auth.is_logged_in() and \
   auth.has_permission('read', db.dog, record.id, auth.user.id)
``:code

uploadフィールドの``authorization``属性は、Noneとするか（デフォルト）、関数を指定することができます。関数は、ユーザーがログインしているかどうか、そして現在の行に対する'read'パーミッションを持っているかどうかを判断します。この例では、"small_image"フィールドにリンクされた画像のダウンロードには何の制限もかけられていません。しかし"large_image"フィールドにリンクされた画像には、アクセス制御がかけられています。

#### アクセス制御とベーシック認証

アクセス制御を行うデコレータが設定されている機能を、サービスとして公開しなければならない場合があります。すなわち、プログラムやスクリプトから呼ばれても、認証と権限チェックを行なえることが必要な場合です。

**Auth** は、ベーシック認証によるログインを可能にできます。
``
auth.settings.allow_basic_login = False
``:code

上記の設定とともに、以下のような機能を定義すると
``
@auth.requires_login()
def give_me_time():
    import time
    return time.ctime()
``:code

次のシェルコマンドから、機能を呼び出すことができます。
``
wget --user=[username] --password=[password]
    http://.../[app]/[controller]/give_me_time
``:code

ベーシック認証によるログインは、しばしば（次章で説明する）サービスに対する唯一のオプションとなります。しかしデフォルトは無効になっています。

#### 手動認証

独自ロジックの実装や"手動"によるログインを行いたい場合が稀にあります。
このような時、次の関数を呼び出すことができます。

``
user = auth.login_bare(username,password)
``:code

``login_bare`` はユーザーが存在しパスワードが正しい時、ユーザー（レコード）を返します。そうでない場合、``None`` を返します。また、"auth_user"テーブルに"username"フィールドがない場合、``username`` はemailになります。

#### 設定とメッセージ

**Auth**のカスタマイズに関係する、全てのパラメタの一覧を以下に示します。

次のパラメタには、``gluon.tools.Mail`` オブジェクトを指定してください。これにより、``auth`` によるメールの送信が可能になります。

``
auth.settings.mailer = None
``:code

次のパラメタには、``user``の機能を定義するコントローラの名前を指定してください。

``
auth.settings.controller = 'default'
``:code

次のパラメタは、とても重要な設定です。

``
auth.settings.hmac_key = None
``:code

これには、"sha512:a-pass-phrase"のような設定をしてください。これは、``auth_user`` テーブルの"password"フィールドに対するCRYPTバリデータへ渡されます。パスワードをハッシュ化するために使われるアルゴリズムとパスフレーズになります。

最小パスワード文字数のデフォルト値は4です。これは変更可能です。
``
auth.settings.password_min_length = 4
``:code

user関数の特定機能を無効にするのは、機能名（パラメータ文字列）を次のリストに追加します。
``
auth.settings.actions_disabled = []
``:code

設定例です。

``
auth.settings.actions_disabled.append('register')
``:code

ユーザー登録を無効にします。

ユーザー登録確認のためのメールを受け取る設定にするには、次を ``True`` にします。

``
auth.settings.registration_requires_verification = False
``:code

ユーザー登録後自動でログインする設定は、次を``True``にします。この場合、メールによるユーザー登録確認プロセス中であっても自動ログインします。

``
auth.settings.login_after_registration = False
``:code

新規のユーザーに対しては、管理者の承認を待ってからログインする設定は、次を ``True`` にします。

``
auth.settings.registration_requires_approval = False
``:code

管理者が承認するにはappadminを使用するかプログラムなどを使って、``registration_key==''`` に変更します。

新規のユーザーに、ユーザー専用のユニークグループを作成しないようにするには、次を ``False`` にします

``
auth.settings.create_user_groups = True
``:code

次の設定は前述のように、代替のログイン方法とログインフォームを決定します。

``
auth.settings.login_methods = [auth]
auth.settings.login_form = auth
``:code

ベーシック認証を使用するときは、次を ``True`` にします。

``
auth.settings.allows_basic_login = False
``:code

次の設定は、``login`` 機能のURLです。

``
auth.settings.login_url = URL('user', args='login')
``:code

既にログインしている状態でユーザー登録用のページを開いた時は、次のURLにリダイレクトします。

``
auth.settings.logged_url = URL('user', args='profile')
``:code

プロファイル（ユーザ登録情報）に画像がある場合に指定する、ダウンロード用のURLです。

``
auth.settings.download_url = URL('download')
``:code

以下は ``auth`` の様々な機能が実行された後に、（参照先が無い場合の）リダイレクト先のURLを指定しています。

``
auth.settings.login_next = URL('index')
auth.settings.logout_next = URL('index')
auth.settings.profile_next = URL('index')
auth.settings.register_next = URL('user', args='login')
auth.settings.retrieve_username_next = URL('index')
auth.settings.retrieve_password_next = URL('index')
auth.settings.change_password_next = URL('index')
auth.settings.request_reset_password_next = URL('user', args='login')
auth.settings.reset_password_next = URL('user', args='login')
auth.settings.verify_email_next = URL('user', args='login')
``:code

呼び出し関数では認証が必要なのに訪問者がログインしていない場合、``auth.settings.login_url`` にリダイレクトします。このデフォルト値は``URL('default','user/login')``になります。再定義することにより、この動作を置き換えることが可能です。
``on_failed_authentication``:inxx

``
auth.settings.on_failed_authentication = lambda url: redirect(url)
``:code

これは認証を失敗した場合のリダイレクト時に呼び出される関数です。``url``引数は、この関数にログインページのURLを渡します。

訪問者がアクセスに必要な十分な権限を所持していない場合、次に指定しているURLにリダイレクトされます。
``on_failed_authorization``:inxx

``
auth.settings.on_failed_authorization = \
    URL('user',args='on_failed_authorization')
``:code

ユーザーが他の場所にリダイレクトするように、この変数を変更することも可能です。

多くの場合、``on_failed_authorization``はURLです。しかしアクセスが失敗した場合に呼び出される、URLを返す関数にすることも可能です。

以下は、バリデーション実施後かつデータベースIO処理前に実行される各機能のコールバック関数の一覧です。

``
auth.settings.login_onvalidation = []
auth.settings.register_onvalidation = []
auth.settings.profile_onvalidation = []
auth.settings.retrieve_password_onvalidation = []
auth.settings.reset_password_onvalidation = []
``:code

各コールバックは``form``オブジェクトを引数とすることが必要です。これにより、データベースのIO処理前に、そのフォームオブジェクトの属性を修正することができます。

以下は、データベースIO処理後かつリダイレクト前に実行する、コールバック関数の一覧です。

``
auth.settings.login_onaccept = []
auth.settings.register_onaccept = []
auth.settings.profile_onaccept = []
auth.settings.verify_email_onaccept = []
``:code

設定例です。

``
auth.settings.register_onaccept.append(lambda form:\
   mail.send(to='you@example.com',subject='new user',
             message="new user email is %s'%form.vars.email))
``:code

いくつかの ``auth`` 機能に対して、キャプチャを有効にできます。

``
auth.settings.captcha = None
auth.settings.login_captcha = None
auth.settings.register_captcha = None
auth.settings.retrieve_username_captcha = None
auth.settings.retrieve_password_captcha = None
``:code

``.captcha`` が ``gluon.tools.Recaptcha`` に設定されている場合、( ``.login_captcha`` などの)個別オプションが ``None`` と指定している機能はすべて、キャプチャが有効になります。もし個別オプションの値が、``False`` だったら、その機能のキャプチャは有効になりません。``.captcha`` が ``None`` に設定されている場合、個別オプションに ``gluon.tools.Recapcha`` を指定している機能のみがキャプチャが有効になり、それ以外の指定が無い機能ではキャプチャは有効にはなりません。

次は、ログインセッションの有効期間です。

``
auth.settings.expiration = 3600  # seconds
``:code

パスワードフィールド名は変更することができます（例えば、Firebirdでは"password"は予約語です。このため、フィールド名として利用できません）。

``
auth.settings.password_field = 'password'
``:code

通常、ログインフォームはメールアドレスでのバリデーションを試みます。次の設定を False にすれば無効にできます。

``
auth.settings.login_email_validate = True
``:code

ユーザプロファイルの編集ページでレコードIDを表示するには、次の設定を True にします。

``
auth.settings.showid = False
``:code

フォームのカスタマイズにおいて、自動的でエラー通知を行いたくない場合は次の設定を False にします。

``
auth.settings.hideerror = False
``:code

フォームのスタイルを変更したい場合は次のようにします。

``
auth.settings.formstyle = 'table3cols'
``:code

（この値は "table2cols"、"divs"及び"ul"を指定することが可能です。）

auth が生成するフォームのラベル区切り記号を設定できます。

``
auth.settings.label_separator =	':'
``:code

"remember me"オプションによって、自動でログイン状態を維持することが可能です。この機能はデフォルトでは有効になっています。次の設定によって、自動ログインの有効期限の変更や、自動ログインのオプション自体を無効にすることができます。

``
auth.settings.long_expiration = 3600*24*30 # one month
auth.settings.remember_me_form = True
``:code

次のメッセージをカスタマイズすることができます。その用途や場面は明らかなため、特に説明はしません。

``
auth.messages.submit_button = 'Submit'
auth.messages.verify_password = 'Verify Password'
auth.messages.delete_label = 'Check to delete:'
auth.messages.function_disabled = 'Function disabled'
auth.messages.access_denied = 'Insufficient privileges'
auth.messages.registration_verifying = 'Registration needs verification'
auth.messages.registration_pending = 'Registration is pending approval'
auth.messages.login_disabled = 'Login disabled by administrator'
auth.messages.logged_in = 'Logged in'
auth.messages.email_sent = 'Email sent'
auth.messages.unable_to_send_email = 'Unable to send email'
auth.messages.email_verified = 'Email verified'
auth.messages.logged_out = 'Logged out'
auth.messages.registration_successful = 'Registration successful'
auth.messages.invalid_email = 'Invalid email'
auth.messages.unable_send_email = 'Unable to send email'
auth.messages.invalid_login = 'Invalid login'
auth.messages.invalid_user = 'Invalid user'
auth.messages.is_empty = "Cannot be empty"
auth.messages.mismatched_password = "Password fields don't match"
auth.messages.verify_email = ...
auth.messages.verify_email_subject = 'Password verify'
auth.messages.username_sent = 'Your username was emailed to you'
auth.messages.new_password_sent = 'A new password was emailed to you'
auth.messages.password_changed = 'Password changed'
auth.messages.retrieve_username = 'Your username is: %(username)s'
auth.messages.retrieve_username_subject = 'Username retrieve'
auth.messages.retrieve_password = 'Your password is: %(password)s'
auth.messages.retrieve_password_subject = 'Password retrieve'
auth.messages.reset_password = ...
auth.messages.reset_password_subject = 'Password reset'
auth.messages.invalid_reset_password = 'Invalid reset password'
auth.messages.profile_updated = 'Profile updated'
auth.messages.new_password = 'New password'
auth.messages.old_password = 'Old password'
auth.messages.group_description = \
    'Group uniquely assigned to user %(id)s'
auth.messages.register_log = 'User %(id)s Registered'
auth.messages.login_log = 'User %(id)s Logged-in'
auth.messages.logout_log = 'User %(id)s Logged-out'
auth.messages.profile_log = 'User %(id)s Profile updated'
auth.messages.verify_email_log = 'User %(id)s Verification email sent'
auth.messages.retrieve_username_log = 'User %(id)s Username retrieved'
auth.messages.retrieve_password_log = 'User %(id)s Password retrieved'
auth.messages.reset_password_log = 'User %(id)s Password reset'
auth.messages.change_password_log = 'User %(id)s Password changed'
auth.messages.add_group_log = 'Group %(group_id)s created'
auth.messages.del_group_log = 'Group %(group_id)s deleted'
auth.messages.add_membership_log = None
auth.messages.del_membership_log = None
auth.messages.has_membership_log = None
auth.messages.add_permission_log = None
auth.messages.del_permission_log = None
auth.messages.has_permission_log = None
auth.messages.label_first_name = 'First name'
auth.messages.label_last_name = 'Last name'
auth.messages.label_username = 'Username'
auth.messages.label_email = 'E-mail'
auth.messages.label_password = 'Password'
auth.messages.label_registration_key = 'Registration key'
auth.messages.label_reset_password_key = 'Reset Password key'
auth.messages.label_registration_id = 'Registration identifier'
auth.messages.label_role = 'Role'
auth.messages.label_description = 'Description'
auth.messages.label_user_id = 'User ID'
auth.messages.label_group_id = 'Group ID'
auth.messages.label_name = 'Name'
auth.messages.label_table_name = 'Table name'
auth.messages.label_record_id = 'Record ID'
auth.messages.label_time_stamp = 'Timestamp'
auth.messages.label_client_ip = 'Client IP'
auth.messages.label_origin = 'Origin'
auth.messages.label_remember_me = "Remember me (for 30 days)"
``:code
``add|del|has`` membership logs allow the use of "%(user_id)s" and "%(group_id)s".
``add|del|has`` permission logs allow the use of "%(user_id)s", "%(name)s", "%(table_name)s", and "%(record_id)s".

### Central Authentication Service
``CAS``:inxx ``authentication``:inxx

web2pyは、サードパーティ認証やシングルサインオンのサポートをしています。
ここでは業界標準で、クライアント及びサーバ共に web2py に組み込まれている、Central Authentication Service (CAS) について取り上げます。

CASは分散認証を行うためのオープンなプロトコルです。次のように動作します。訪問者がWebサイトにアクセスした時、アプリケーションはユーザーが既に認証されているかどうかをセッションを使ってチェックします（例、``session.token`` オブジェクトを経由）。もし認証されていない場合、コントローラはCASアプライアンスからユーザーをリダイレクトします。リダイレクト先は、ユーザーがログイン、ユーザー登録、認証情報の管理（名前、メールアドレス、パスワード）ができるところです。
ユーザー登録をした場合は、そのユーザーが登録確認メールに対応するまで登録を保留します。登録が完了しログインすると、CASアプライアンスはキーとともにユーザーをアプリケーションへリダイレクトします。アプリケーションではこのキーを使って、ユーザーの認証情報を取得します。これはバックグランドで、CASサーバとのHTTPリクエストを介して実行します。

この仕組みを使うと、複数のアプリケーションが一つのCASサーバを通してシングルサインオンを使用することができます。認証を提供するサーバは、サービスプロバイダと呼びます。訪問者を認証しようとするアプリケーションは、サービスコンシューマと呼びます。

CASはOpenIDと似ていますが、大きな違いが一つあります。OpenIDの場合、訪問者はサービスプロバイダを選択することができます。CASの場合は、アプリケーションがサービスプロバイダを選択します。そのため、CASはより安全です。

web2pyのCASプロバイダを実行するのはひな形アプリケーションをコピーするのと同じくらい簡単です。実際に機能を公開したweb2pyアプリケーションを次に示します。

``
## in provider app
def user(): return dict(form=auth())
``

CAS 2.0 プロバイダです。そのサービスはURLでアクセスできます。

``
http://.../provider/default/user/cas/login
http://.../provider/default/user/cas/validate
http://.../provider/default/user/cas/logout
``:code
(アプリケーションは "provider" と呼ばれると仮定しています)

プロバイダに対するシンプルな代理認証によって、他のWebアプリケーション（コンシューマ）からサービスにアクセス可能です。

``
## in consumer app
auth = Auth(db,cas_provider = 'http://127.0.0.1:8000/provider/default/user/cas')
``:code

コンシューマアプリケーションのログインURLにアクセスすると、認証の働きをするプロバイダアプリケーションにリダイレクトし、さらにコンシューマにリダイレクトで戻ります。ユーザ登録、ログアウト、パスワード変更、パスワードの再確認などのすべての処理は、プロバイダアプリケーション上で完結します。拡張フィールドやローカルプロファイルのために、コンシューマにログインユーザのエントリが作成されます。幸いのことに CAS 2.0 は、すべてのフィールドはプロバイダ上で読み取り可能です。そして コンシューマの ``auth_user`` テーブルに相当するフィールドは、自動でコピーされます。

``Auth(...,cas_provider='...')`` はサードパティのプロバイダと共に動作し、CAS 1.0 及び 2.0 をサポートします。バージョンの検出は自動で行います。デフォルトでは追加することにより、ベース（上記の ``cas_provider`` URL）からプロバイダのURLを生成します。

``
/login
/validate
/logout
``:code

次の設定は、コンシューマとプロバイダで変更できます。

``
## in consumer or provider app (must match)
auth.settings.cas_actions['login']='login'
auth.settings.cas_actions['validate']='validate'
auth.settings.cas_actions['logout']='logout'
``

別ドメインからweb2py CASプロバイダに接続する場合は、許可ドメインのリストに追加する必要があります。

``
## in provider app
auth.settings.cas_domains.append('example.com')
``:code

#### web2pyを使用した、非web2pyアプリケーションの認可

これは可能ですが、Webサーバに依存します。
前提として、２つのアプリケーションは同じ ``mod_wsgi`` を使った Apatchサーバで動作するとします。
一方のアプリケーションは Auth を使用したアクセス制御を行う web2py アプリケーションです。
もう一方は CGIスクリプトのPHPプログラムなどです。
後者のアプリケーションにアクセス要求があった時、Webサーバは前者にパーミッションを問い合わせるようにします。

最初にweb2pyアプリケーションを修正して、次のコントローラを追加する必要があります。

``
def check_access():
    return 'true' if auth.is_logged_in() else 'false'
``:code

このコントローラから ``true`` が返ってくる時はユーザはログインしています。``false`` の時はそうでない時です。このweb2pyのプロセスはバックグランドで動作しています。

``
nohup python web2py.py -a '' -p 8002
``

ポート8002 は必須です。adminの有効化とadminパスワードは必要ありません。

ここで Apacheの設定ファイル(例 "/etc/apache2/sites-available/default")を修正します。非web2pyプログラムの動作時に上記のチェックプログラムを呼び出し、 ``true`` だった場合はレクエストに対するレスポンスを返し、他の場合はアクセス拒否を行うようにします。

web2pyと非web2pyはアプリケーションは同一ドメインで実行されます。このためユーザーがweb2pyアプリケーションにログインしている場合は、他のアプリケーションからの要求であってもweb2pyのセッションクッキーをApacheに渡すため、認証情報の確認が可能になります。

これを実施するためには、"web2py/scripts/access.wsgi"スクリプトが必要になります。
web2pyでは、このスクリプトが付属しています。アクセス制御が必要なアプリケーションのURLとスクリプトの位置をApacthに知らせて、このスクリプトを呼び出す必要があります。

``
<VirtualHost *:80>
   WSGIDaemonProcess web2py user=www-data group=www-data
   WSGIProcessGroup web2py
   WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

   AliasMatch ^myapp/path/needing/authentication/myfile /path/to/myfile
   <Directory /path/to/>
     WSGIAccessScript /path/to/web2py/scripts/access.wsgi
   </Directory>
</VirtualHost>
``

ここで "^myapp/path/needing/authentication/myfile" は、受信レクエストとweb2pyフォルダの絶対パス "/path/to/" をマッチさせる正規表現になっています。

"access.wsgi"スクリプトは次の行を含んでいます。

``
URL_CHECK_ACCESS = 'http://127.0.0.1:8002/%(app)s/default/check_access'
``

これは、web2pyアプリケーションを指定してます。しかし、8002以外のポートで実行している特定のアプリケーションを指定するよう、編集することが可能です。

また、`` check_access（）`` 機能を変更し、ロジックをより複雑にすることができます。この機能は環境変数を使用し、最初のリクエストのURLを取得することができます

``
request.env.request_uri
``

より複雑なルールに実装できます。

``
def check_access():
    if not auth.is_logged_in():
       return 'false'
    elif not user_has_access(request.env.request_uri):
       return 'false'
    else:
       return 'true'
``:code

##### 第3版 - 翻訳: 中垣健志　レビュー: 細田謙二
##### 第4版 - 翻訳: Hitoshi Kato　レビュー: Omi Chiba