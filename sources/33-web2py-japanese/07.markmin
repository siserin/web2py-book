## フォームとバリデータ

web2pyでフォームを構築するには以下の4通りの方法があります：
- ``FORM`` はHTMLヘルパに関して低レベルの実装を提供します。``FORM``オブジェクトはHTMLへとシリアライズすることができ、そこに含まれるフィールドについて把握しています。``FORM``オブジェクトは送信フォームの値を検証することができます。
- ``SQLFORM`` は、作成、更新、削除のフォームを、既存のデータベーステーブルから構築するための高レベルのAPIを提供します。
-``SQLFORM.factory``は``SQLFORM``の上にある抽象化レイヤです。データベースが用意されてない場合でもフォーム生成機能を活用できるようにしています。これは、テーブルの記述から``SQLFORM``ととても良く似たフォームを生成します。ただしデータベース・テーブルを作成する必要はありません。
- ``CRUD``メソッド。SQLFORMと同等でSQLFORMに基づく関数が用意されていますが、よりコンパクトな表記が可能になります。

これらすべてのフォームは自分自身を把握しており、入力が検証を通らなかった場合、自分自身を修正してエラーメッセージを加えることができます。フォームでは、検証によって生成された検証済み変数とエラーメッセージを問い合わせることができます。

ヘルパを用いて、任意のHTMLコードをフォームへ挿入、また、フォームから抽出することができます。

``FORM``と``SQLFORM``はヘルパで``DIV``のように扱えます。例えば、フォームスタイルを指定できます：

``
form = SQLFORM(..)
form['_style']='border:1px solid black'
``:code

### ``FORM``
``form``:inxx ``accepts``:inxx ``formname``:inxx

次のような"default.py"コントローラを持つ**test**アプリケーションを考えます：
``
def display_form():
    return dict()
``:code

関連付けるビュー"default/display_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

これは、ユーザー名を問い合わせる一般的なHTMLフォームです。このフォームを入力しサブミット・ボタンをクリックすると、フォームは自分自身をサブミットし、``request.vars.name``変数とその値が下部に表示されます。

同じフォームをヘルパを用いて生成することができます。これは、ビュー、または、アクションにおいて行うことができます。web2pyはフォームの処理をアクションにおいて行うので、フォームをアクションで定義しても差し支えありません。

これが新しいコントローラです：
``
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

以前のコードは上のコードと等しいです。しかし、フォームは、``FORM``オブジェクトをシリアライズする``{{=form}}``という文によって生成されています。

次に、フォームの検証と処理を追加して、一段複雑なものを加えます。

コントローラを以下のように変更します：
``
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request,session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
``:code

以下のことに注意してください：
- アクションでは、入力フィールド"name"に対して``requires=IS_NOT_EMPTY()``バリデータを加えています。
- アクションでは、``form.accepts(...)``の呼び出しを加えています。
- ビューでは、フォームと``request.vars``とともに``form.vars``と``form.errors``を表示しています。

すべての作業は、``form``オブジェクトの``accepts``メソッドによって行われます。これは、``request.vars``を、(バリデータによって表現された)宣言された要求に従って、フィルタします。``accepts``は、検証を通ったこれらの変数を``form.vars``に格納します。フィールドの値が何かしら要求を満たさない場合は、失敗したバリデータがエラーを返し、そのエラーが``form.errors``に格納されます。``form.vars``と``form.errors``は両方とも、``request.vars``に似た``gluon.storage.Storage``オブジェクトです。前者は、次のように検証を通った値を保持します：
``
form.vars.name = "Max"
``:code

後者は、次のようにエラーを保持します：
``
form.errors.name = "Cannot be empty!"
``:code

``accepts``メソッドのすべての用法は以下の通りです：
``onvalidation``:inxx
``
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
``:code

これらオプション・パラメータの意味は、次の小節で説明します。

最初の引数には``request.vars``、``request.get_vars``、``request.post_vars``や、単に``request``と指定できます。後者は``request.post_vars``と入力したのと等しく処理されます。

``accepts``関数はフォームが受理されたときに``True``を返し、そうでない場合は``False``を返します。フォームは、エラーがある場合か、サブミットされてない場合(たとえば、最初に表示されるとき)には受理されません。

次に示すのは、このページが最初に表示されたときの様子です：

[[image @///image/en5800.png center 300px]]

無効なサブミットをしたときの様子です：

[[image @///image/en5900.png center 300px]]

有効なサブミットをしたときの様子です：

[[image @///image/en6000.png center 300px]]

#### ``process``と``validate``メソッド

以下のショートカットは
``
form.accepts(request.post_vars,session,...)
``:code
このようになります
``
form.process(...).accepted
``:code
後者は``request``と``session``引数を必要としません（任意で指定は可能ですが）。またフォーム自身を返すため、``accepts``とは異なります。内部的には、``process``がacceptsを呼び出し、その引数を渡します。acceptsによって返された値が``form.accepted``に保存されます。

process関数は``accepts``に存在しない追加の引数を受け取れます。
- ``message_onsuccess``
- ``onsuccess``: 'flash' (既定)に相当し、フォームが受理されると上記の`message_onsuccess``を表示します。
- ``message_onfailure``
- ``onfailure``: 'flash' (既定)に相当し、 フォームが検証を通らなかった場合、上記の`message_onfailure``を表示します。
- ``next`` フォームが受理されるとユーザーはリダイレクトされます。
``onsuccess``と``onfailure`` には``lambda form: do_something(form)``のような関数も使用できます。

``
form.validate(...)
``:code

は以下のショートカットです。

``
form.process(...,dbio=False).accepted
``:code

#### 隠しフィールド

上記のフォーム・オブジェクトが``{{=form}}``によってシリアライズされたとき、``accepts``メソッドに対する前述の呼び出しがあるために、フォームは次のようになります：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

注意する点は、2つの隠しフィールド"_formkey"と"_formname"があることです。これらの存在は、``accepts``の呼び出しによって引き起こされたもので、2つの異なる重要な役割を果たします：
- "_formkey"という隠しフィールドは一度限りのトークンで、web2pyがフォームの二重投稿を防ぐために用いられます。このキーの値はフォームがシリアライズされたときに生成され、``session``に保存されます。フォームがサブミットされたときに、この値が一致する必要があります。そうでないと``accepts``は、フォームが全くサブミットされてないかのように、エラーなしで``False``を返します。これは、フォームが正しくサブミットされたかどうかをweb2pyが判断できないためです。
- "_formname"という隠しフィールドは、フォームの名前としてweb2pyによって生成されますが、その名前は上書きすることができます。このフィールドは、ページが複数のフォームを含んで処理することを可能にするために必要です。web2pyは、この名前によって異なるサブミットされたフォームを区別します。
- オプション的な隠しフィールドは``FORM(..,hidden=dict(...))``のように指定します。

これらの隠しフィールドの役割と、カスタムフォームと複数のフォームを持つページにおける使用方法は、本章の後半で詳しく説明します。

上記のフォームを空の"name"フィールドでサブミットした場合、フォームは検証を通過しません。フォームが再びシリアライズされるときは、次のように表示されます：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

シリアライズしたフォームにあるDIVのクラス"error"の存在に注意してください。web2pyはこのエラーメッセージをフォームに挿入し、検証を通過しなかったフィールドについて訪問者に知らせます。サブミットの際の``accepts``メソッドは、フォームがサブミットされたかどうかを判断し、フィールド"name"が空でないか、また、それが要求されているかをチェックし、最終的に、バリデータからフォームにエラーメッセージを挿入します。

基底の"layout.html"ビューは、DIVクラスの"error"を処理することが想定されています。デフォルトのレイアウトはjQueryのエフェクトを使用して、エラーを可視化し、赤い背景とともにスライドダウンさせます。詳細は第11章を参照してください。

#### ``keepvalues``

``keepvalues``:inxx

オプション引数``keepvalues``は、フォームが受理され、かつ、リダイレクトがないときに、web2pyに何をするか知らせ、同じフォームが再び表示されるようにします。デフォルトではすべてクリアされます。``keepvalues``が``True``の場合、フォームは前回挿入した値を事前に入力します。これは、複数の似たレコードを繰り返し挿入するために使用することを想定したフォームがあるときに便利です。``dbio``引数が``False``の場合、web2pyは、フォームを受理した後、いかなるDBの挿入/更新も行いません。``hideerror``が``True``でフォームにエラーが含まれている場合、フォームがレンダリングされたときにエラーは表示されません(``form.errors``をどのように表示するかは開発者次第です)。``onvalidation``引数は以下に説明します。

#### ``onvalidation``

``onvalidation``引数は``None``もしくは、フォームを受け取り何も返さない関数をとることができます。そのような関数は、検証(が通った)直後に、かつ、それ以外のことが発生する前に呼ばれ、フォームを渡します。この関数の目的は複数あります。これは、たとえば、追加的なフォームのチェックを実行したり、最終的にフォームにエラーを加えたりすることができます。これはまた、いくつかのフィールドの値を、他のフィールドの値に基づいて計算するのに使用することもできます。これを用いて、レコードが作成/更新される前にいくつかのアクション(emailの送信など)を引き起こすことも可能です。

以下がその例です。
``
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)
``:code

#### レコード変更の検知

レコードを編集するためにフォームを入力している際に、わずかですが他のユーザーが同じレコードを同時に変更している可能性があります。そこでレコードを保存する際に競合していないかチェックしたいです。これは以下のように実施できます。

``
db.define_table('dog',Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog,dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)
``:code

#### フォームとリダイレクト

フォームを使用する最も一般的な方法は、自己サブミットを介して、サブミットされたフィールドの変数が、フォームを生成したものと同じアクションによって処理されるようにすることです。フォームが一旦受理されれば、現在のページを再び表示することはあまりありません(ここでは説明を単純にするためいくつか行っています)。訪問者を"next"ページへリダイレクトさせるのがより一般的です。

ここでは新しいコントローラの例を示します：
``
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
``:code

現在のページの代わりにnextページでflashを設定するために、``session.flash``を``response.flash``の代わりに設定する必要があります。web2pyはリダイレクト後、前者を後者に移します。``session.flash``は``session.forget()``を使用していないことが前提であることに注意してください。

#### ページ毎に複数のフォーム

この節の内容は、FORMとSQLFORMオブジェクトどちらにも適用されます。
ページ毎に複数のフォームを持つことが可能です。しかし、web2pyにそれらを区別できるようにしなければなりません。異なるテーブルの``SQLFORM``によって生成されたものならば、web2pyは異なる名前を自動的にそれらに与えます。それ以外の場合は、異なるフォームの名前を明示的に与えなければなりません。以下がその例です。
``
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
``:code

ここに生成された出力を示します：

[[image @///image/en6100.png center 300px]]

訪問者が空のform1をサブミットした場合、form1のみがエラーを表示します。一方、訪問者が空のform2をサブミットした場合、form2のみがエラーメッセージを表示します。

#### フォームの共有

この節の内容は、``FORM``と``SQLFORM``オブジェクトどちらにも適用されます。ここで説明することは可能ですが推奨されません。自己サブミットするフォームを持つことがベストプラクティスだからです。しかし、場合によっては、フォームを送受信するアクションが異なるアプリケーションに属していて、選択肢がないことがあります。

異なるアクションへサブミットするフォームを生成することは可能です。これは、``FORM``または``SQLFORM``オブジェクトの属性において、処理するアクションのURLを指定することで行われます。例:
``
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
``:code

"page_one"と"page_two"は両者とも同じ``form``を利用しているので、同じことの繰り返しを避けるために、そのフォームをすべてのアクションの外側で一度だけ定義していることに注意してください。コントローラの冒頭にある共通のコード部分は、アクションの呼び出しに制御を渡す前に毎回実行されます。

"page_one"は``process``(または、``accepts``）を呼び出さないため、formには名前がなくキーもありません。そのため、``session=None``を渡し、``formname=None``を設定する必要があります。そうでないと、フォームは"page_two"に受け取られたときに検証を行いません。

### ``SQLFORM``

次の段階に進んで、以下のようなアプリケーションのモデルファイルを用意します：
``
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
``:code

コントローラを以下のように変更します：
``
def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
``:code

ビューを変更する必要はありません。

コントローラでは、``FORM``を構築する必要はありません。なぜなら、``SQLFORM``は、モデルに定義された``db.person``テーブルからそれを構築するからです。この新しいフォームがシリアライズされると次のように表示されます：
``
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
``:code

この自動的に生成されたフォームは、前述の低レベルのフォームよりも複雑です。第1に、これはテーブルの行を含み、各行は3つのカラムを持っています。最初のカラムはフィールドの名前を保持しています(``db.person``から決定されます)。第2のカラムは入力フィールドを保持します(最終的にエラーメッセージも保持します)。第3のカラムは省略可能で空になっています(``SQLFORM``のコンストラクタにおいてフィールドを用いて入力される可能性があります)。

フォームのすべてのタグには、テーブルとフィールドの名前に由来する名前が付けられています。これによりCSSとJavaScriptを用いてフォームをカスタマイズするのが容易になります。この機能については、第11章で詳しく説明します。

ここでより重要なのは、``accepts``メソッドがより多くの仕事をすることです。前回の場合と同様、入力の検証を行いますが、加えて、入力が検証を通ったら、データベースに対して新規レコードの挿入を実行し、``form.vars.id``に新規レコードのユニークな"id"を格納します。

``SQLFORM``オブジェクトはまた、自動的に"upload"フィールドを処理し、アップロードしたファイルを"uploads"フォルダに保存します(競合を避けるため安全にリネームして、ディレクトリ・トラバーサル攻撃を防いだ後に保存します)。そして、(新しい)ファイル名をデータベースの適切なフィールドに保存します。フォームが処理されると、新しいファイル名は``form.vars.fieldname``（つまり、``cgi.FieldStorage``オブジェクトの値を``request.vars.fieldname``に置き換える）で参照可能なので、更新後、簡単にその名前を参照することができます。

``SQLFORM``は、"boolean"の値をチェックボックスで、"text"の値をテキストエリアで、限定したセットまたはデータベース内に含まれることを要求された値をドロップボックスで、"upload"フィールドをアップロードしたファイルをダウンロードできるようにしたリンクで、表示します。"blob"フィールドは非表示します。後述しますが、異なる方法で処理されることになるからです。

たとえば、次のモデルを考えてください：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
``:code

この場合、``SQLFORM(db.person)``は次に表示されるようなフォームを生成します：

[[image @///image/en6200.png center 300px]]

``SQLFORM``のコンストラクタは、さまざまなカスタマイズを可能にします。たとえば、フィールドの一部のみを表示したり、ラベルを変更したり、オプション的な第3のカラムに値を加えたり、現在のINSERTフォームとは対照的にUPDATEとDELETEフォームを作成したりすることができます。``SQLFORM``はweb2pyにおいて、最も大きく時間を節約できる単一のオブジェクトです。

``SQLFORM``クラスは"gluon/sqlhtml.py"に定義されています。これは、``xml``メソッドをオーバライドして簡単に拡張することができます。このメソッドはこのオブジェクトをシリアライズして、その出力を変更します。

``fields``:inxx ``labels``:inxx
``SQLFORM``のコンストラクタの用法は以下の通りです：
``
SQLFORM(table, record = None,
        deletable = False, linkto = None,
        upload = None, fields = None, labels = None,
        col3 = {}, submit_button = 'Submit',
        delete_label = 'Check to delete:',
        showid = True, readonly = False,
        comments = True, keepopts = [],
        ignore_rw = False, record_id = None,
        formstyle = 'table3cols',
	buttons = ['submit'], separator = ': ',
        **attributes)

``:code
- オプション的な第2の引数は、INSERTフォームから、指定したレコードに対するUPDATEフォームに切り替えます(次の小節を参照してください)。``showid``:inxx ``delete_label``:inxx ``id_label``:inxx ``submit_button``:inxx
``deletable``が``True``の場合、UPDATEフォームは"Chceck to delete"というチェックボックスを表示します。フィールドがある場合、このラベルの値は``delete_label``引数を介して設定されます。
- ``submit_button``はサブミット・ボタンの値を設定します。
- ``id_label``はレコードの"id"のラベルを設定します。
- ``showid``が``False``の場合、レコードの"id"は表示されません。
``fields``は表示したいフィールド名のオプション的なリストです。リストが提供されている場合、リスト内のフィールドしか表示されません。例:
``
fields = ['name']
``:code
-  ``labels``はフィールドラベルの辞書です。辞書のキーはフィールド名で、対応する値はラベルとして表示されるものです。ラベルが提供されていない場合、web2pyはラベルをフィールド名から生成します(フィールド名を大文字で書き始めアンダースコアをスペースに置換します)。例:
``
labels = {'name':'Your Full Name:'}
``:code
- ``col3``は第3のカラム用の辞書の値です。例:
``
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
``:code
- ``linkto``と``upload``は、ユーザー定義コントローラへのオプション的なURLです。これにより、フォームで参照フィールドを扱うことが可能になります。これについては、後述の節で詳説します。
- ``readonly``。Trueの場合、読み取り専用のフォームを表示します。
- ``comments``。Falseの場合、col3のコメントを表示しません。
- ``ignore_rw``。通常は、作成/更新フォームに対して、writable=Trueでマークされたフィールドしか表示されず、読み取り専用フォームに対しては、readable=Trueでマークしたフィールドしか表示されません。``ignore_rw=True``に設定すると、これらの制約は無視され、すべてのフィールドが表示されます。これは主に、appadminインターフェースにおいて、モデルの意図を覆して、各テーブルのすべてのフィールドを表示するために使用されます。
- ``formstyle``:inxx ``formstyle``フォームをhtmlにシリアライズするときに使用されるスタイルを決めます。次の値をとることができます："table3cols"(デフォルト)、"table2cols"(一行にラベルとコメントを、もう1つの行に入力を表示します)、"ul"(入力フィールドの順序なしリストを作成します)、"divs"(フォームをcssフレンドリなdivで表現します)。 ``formystyle``はまた、(record_id, field_label, field_widget, field_comment)を属性として受け取り、TR()オブジェクトを返す関数をとることもできます。

- ``buttons``:inxx ``buttons``は``INPUT``や``TAG.BUTTON``（技術的にはあらゆるヘルパの組み合わせを使用できるが）のリストで、submitボタンが配置されるDIVに追加されます。
- ``separator``:inxx ``separator``はフォームのラベルと入力フィールドの間に区切り文字を設定します。
- オプション的な``attributes``は、``SQLFORM``オブジェクトをレンダリングする``FORM``タグに対して渡したいアンダースコアで始まる引数群です。たとえば次のようになります：
``
_action = '.'
_method = 'POST'
``:code

特別な``hidden``属性があります。辞書が``hidden``として渡されたとき、その項目は"hidden"INPUTフィールドに変換されます(第5章の``FORM``ヘルパの例を参照してください)。

``
form = SQLFORM(....,hidden=...)
``:code
隠しフィールドはサブミットによって渡されるため、``form.accepts(...)``は受信した隠しフィールドを読み込み、form.varsに値を渡すといっと動作は行いません。これはセキュリティ上の理由です。隠しフィールドは改ざんされる可能性があるからです。このため、隠しフィールドをrequestからフォームに明示的に移動する必要があります。

``
form.vars.a = request.vars.a
form = SQLFORM(..., hidden=dict(a='b'))
``:code

#### ``SQLFORM``と``insert``/``update``/``delete``
``SQLFORM``はフォームが受理されると新しいレコードを作成します。以下の例を考えてみると、
``form=SQLFORM(db.test)``:code　このとき、最後に作成されたレコードのidは``form.vars.id``で参照できます。

``delete record``:inxx
レコードを``SQLFORM``コンストラクタのオプション的な第2の引数に渡した場合、フォームはそのレコードに対するUPDATEフォームになります。つまり、フォームがサブミットされると既存のレコードが更新され新しいレコードは挿入されません。``deletable=True``属性を設定して場合は、UPDATEフォームは"Check to delete"というチェックボックスを表示します。チェックされると、レコードは削除されます。

------
フォームがサブミットされ、削除チェックボックスがチェックされている場合は、``form.deleted``属性に``True``が設定されます。
------

たとえば、前述の例のコントローラを修正し、次のように、URLのパスに追加の整数引数を渡すことができます。
``
/test/default/display_form/2
``:code

これに対応するidを持つレコードがあると、``SQLFORM``は、このレコードのためのUPDATE/DELETEフォームを生成します：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

2行目でレコードを見つけ、3行目でUPDATE/DELETEフォームを作り、4行目はすべての対応するフォームの処理を行います。

------
更新フォームは作成フォームにとても似ていますが、現在のレコードによって事前入力され、プレビュー画像も表示します。デフォルトでは、``deletable = True``になっていて、"delete record"オプションが更新フォームに表示されます。
------

編集フォームはまた、``name="id"``という隠れINPUTフィールドを保持しています。これによりレコードが特定できるようになります。このidはまた、追加のセキュリティのためサーバーサイドで保存され、訪問者がフィールドの値を改ざんした場合、UPDATEは実行されず、web2pyは"user is tampering with form"となるSyntaxErrorを発生させます。

Fieldが``writable=False``としてマークされていると、フィールドは作成フォームに表示されず、読み込み専用の更新フォームで表示されます。フィールドが``writable=False``、かつ、``readable=False``としてマークされている場合、フィールドは、更新フォームを含むすべてのフォーム上で表示されません。

次のように作成されたフォームは、
``
form = SQLFORM(...,ignore_rw=True)
``:code

``readable``と``writable``の属性を無視して、常にすべてのフィールドを表示します。``appadmin``のフォームはデフォルトでそれらを無視します。

次のように作成されたフォームは、
``
form = SQLFORM(table,record_id,readonly=True)
``:code

常に、読み取り専用モードですべてのフィールドを表示し、フォームが受理することはありません。

#### HTMLにおける``SQLFORM``

``SQLFORM``のフォームをその生成と処理機能から利便を享受するために使用したいが、``SQLFORM``オブジェクトのパラメタではできなくらいのHTMLのカスタマイズが必要で、HTMLを用いてフォームを設計しなければならないことがあります。

では、前回のコントローラを編集し新しいアクションを追加してみます：
``
def display_manual_form():
   form = SQLFORM(db.person)
   if form.process(session=None, formname='test').accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill the form'
   # Note: no form instance is passed to the view
   return dict()
``:code

そして、関連付けられたビュー"default/display_manual_form.html"にフォームを挿入します：
``
{{extend 'layout.html'}}
<form>
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
``:code

ここで、アクションはフォームを返していないことに注意してください。なぜならビューに渡す必要がないからです。ビューはHTMLにおいて手動で作成されたフォームを含んでいます。フォームは、隠れフィールド"_formname"を含んでいて、それはアクションの``accepts``の引数で指定された``formname``と必ず同じにしなければなりません。web2pyは同じページに複数のフォームがある場合に、どれからサブミットされたかを判断するのに、フォームの名前を使用します。ページが単一のフォームからなる場合、``formname=None``と設定して、ビューにおける隠れフィールドを見送ることができます。

``form.accepts``はデータベーステーブル``db.person``のフィールドに適合するデータを``response.vars``内から検索します。これらのフィールドは以下のようにHTMLで宣言することができます。
``<input name="field_name_goes_here" />
``:code

上記の例では、フォーム変数がURLの引数として渡される点に注意してください。そうしたくない場合、``POST``プロトコルが指定される必要があります。さらに、uploadフィールドが指定された場合は、フォーム上でそれを許可するように設定しなければなりません。両方のオプションを以下に示します。
``
<form enctype="multipart/form-data" method="post">
``:code

#### ``SQLFORM``とアップロード

"upload"型のフィールドは特殊です。それらは、``type="file"``のINPUTフィールドでレンダリングされます。特に指定がない限り、アップロードしたファイルはバッファにストリームされ、自動的に割り当てられる新しい安全な名前を用いて、アプリケーションの"upload"フォルダに保存されます。このファイルの名前はこのとき、アップロード型のフィールドに保存されます。

例として、次のモデルを考えてください：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
``:code

先ほどのコントローラアクション"display_form"と同じものを利用することができます。

新規のレコードを挿入するとき、フォームはファイルに対する閲覧を可能にします。たとえば、jpg画像を選択してください。このファイルはアップロードされ、次のように保存されます：
``
applications/test/uploads/person.image.XXXXX.jpg
``:code

"xxxxxx"は、web2pyによってこのファイルに割り当てられるランダムな識別子になります。

``content-disposition``:inxx

-------
デフォルトでは、アップロードしたファイルの元のファイル名はb16エンコードされ、そのファイルに対する新しい名前の構築に使用されることに注意してください。この名前は、デフォルトの"download"アクションによって取り出され、元のファイルへのContent-Dispositionヘッダを設定するのに使用されます。
-------

拡張子だけがそのままになります。これはセキュリティ上の理由です。なぜなら、ファイル名は特別な文字列を含む可能性があり、訪問者にディレクトリ・トラバーサル攻撃や他の悪意のある操作を許してしまうからです。

新しいファイル名は``form.vars.image``にも格納されます。

UPDATEフォームを使用してレコードを編集するとき、既存のアップロードしたファイルへのリンクを表示するのは便利で、web2pyはその方法を提供しています。

URLをupload引数を介して``SQLFORM``のコンストラクタに渡す場合、web2pyは、ファイルをダウンロードするために、そのURLのアクションを用います。次のアクションを考えてください：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
``:code

さて、次のURLにて新規のレコードを挿入してみます：
``
http://127.0.0.1:8000/test/default/display_form
``:code

画像をアップロード、フォームをサブミットして、次のURLを訪れて新しく作られたレコードを編集します：
``
http://127.0.0.1:8000/test/default/display_form/3
``:code

(ここでは最新のレコードがid=3をもつと仮定します)。フォームは以下に示すように画像のプレビューを表示します：

[[image @///image/en6300.png center 300px]]

このフォームは、シリアライズされるときに、次のようなHTMLを生成します：
``
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
``:code

これは、アップロードしたファイルをダウンロードするリンクと、データベースのレコードからこのファイルを削除するためのチェックボックスを含んでいます。したがって、"image"フィールドにはNULLが格納されています。

なぜ、このような機構が公開されているのでしょうか？なぜ、ダウンロード関数を書く必要があるのでしょうか？なぜなら、いくつかの認証メカニズムをダウンロード関数に課すことが必要になるかもしれないからです。例は、第9章を参照してください。

通常アップロードファイルは"app/uploads"の中に保存されますが、別の場所を指定することもできます。
``
Field('image', 'upload', uploadfolder='...')
``
多くのオペレーティングシステムにおいて、同一のフォルダ内に大量のファイルがある場合はファイルシステムへの接続が遅くなる場合があります。もし1000以上のファイルをアップロードする予定があるならば、web2pyにサブフォルダでアップロードファイルを整理するように指示できます。
``
Field('image', 'upload', uploadseparate=True)
``


#### 元のファイル名の保存

web2pyは自動的に元のファイル名を新しいUUIDのファイル名の中に保存し、ファイルがダウンロードされたときにそれを取り出します。ダウンロードの際、オリジナルのファイル名は、HTTPレスポンスのContent-Dispositionヘッダに格納されます。これはすべて、プログラミングの必要なしに透過的に行われます。

時には、オリジナルのファイル名をデータベースのフィールドに保存したい場合もあります。この場合、モデルを修正し、それを保存するフィールドを加える必要があります：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
``:code

そして、それを処理するようにコントローラーを修正する必要があります：
``
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image!=None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

``SQLFORM``は"image_filename"フィールドを表示していないことに注意してください。"display_form"アクションは、``request.vars.image``のファイル名を``form.vars.image_filename``に移動します。これにより、``accepts``においてファイル名を処理し、データベースに保存することができるようになります。ダウンロード関数は、そのファイルを配信する前に、元のファイル名をデータベースにおいてチェックし、Content-Dispositionヘッダにおいて使用します。

#### ``autodelete``
``autodelete``:inxx

レコードを削除する際に、``SQLFORM``はレコードによって参照された物理的なアップロード・ファイルを削除することはありません。その理由は、web2pyがそのファイルが他のテーブルによって使用/リンクされているか、また、他の目的で使用されているかどうか知ることができないからです。対応するレコードが削除されたとき、実際のファイルを削除しても安全だと判断できる場合は、次のようにして削除できます：
``
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('file','upload',autodelete=True))
``:code

``autodelete``属性はデフォルトでは``False``です。``True``に設定すると、レコードが削除されるとき、ファイルも削除されるようになります。

#### 参照レコードへのリンク

今度は、参照フィールドによってリンクされた2つのテーブルを考えます。
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', db.person),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')
``:code

飼い主は犬を飼い、犬は所有者(owner)、つまり、飼い主に所属しています。犬の所有者(owner)には、有効な``db.person.id``を``'%(name)s'``を用いて参照することが要求されます。

このアプリケーションの**appdadmin**インターフェースを用いて、何人かの飼い主と彼らの犬を加えましょう。

既存の飼い主を編集するとき、**appadmin**のUPDATEフォームは、この飼い主に属する犬の一覧を表示するページへのリンクを表示します。この挙動は、``SQLFORM``の``linkto``引数を用いて真似することができます。``linkto``は、``SQLFORM``からのクエリ文字列を受け取って対応するレコードを返す新規のアクションのURLを指す必要があります。以下がその例です。
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True,
                  upload=url, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

これがそのページです：

[[image @///image/en6400.png center 300px]]

"dog.owner"というリンクがあります。このリンクの名前は、次のような``SQLFORM``の``labels``引数を介して変更することができます：
``
labels = {'dog.owner':"This person's dogs"}
``:code

リンクをクリックすると、次の場所に向かいます：
``
/test/default/list_records/dog?query=dog.owner%3D5
``:code

"list_records"は指定されたアクションで、``request.args(0)``に参照するテーブルの名前が設定され、``request.vars.query``にSQLのクエリ文字列が設定されています。URLのクエリ文字列は適切にurlエンコードされた"dog.owner=5"の値を含んでいます(web2pyはURLを解析するときに自動的にこれをデコードします)。

とても汎用的な"list_records"アクションを次のように簡単に実装することができます：
``
def list_records():
    table = request.args(0)
    query = request.vars.query
    records = db(query).select(db[table].ALL)
    return dict(records=records)
``:code

関連付けられるビュー"default/list_records.html"は次のようにします：
``
{{extend 'layout.html'}}
{{=records}}
``:code

選択によってレコードセットが返され、ビューでシリアライズされるとき、これは最初にSQLTABLEオブジェクト(Tableと同じではありません)に変換された後、各フィールドがテーブルのカラムと対応するHTMLテーブルへとシリアライズされます。

#### フォームの事前入力
次の構文を用いて、フォームを事前入力することは常に可能です：
``
form.vars.name = 'fieldvalue'
``:code

上記のような文は、フィールド(この例では"name")が明示的にフォームで表示されているかにかかわらず、フォームの宣言の後、かつ、フォームの受理の前に挿入される必要があります。

#### ``SQLFORM``に要素の追加
フォーム作成後に要素を追加したい場合があります。例えば、あなたのウェブサイトの会員規約に同意するかどうかのチェックボックスを追加したい場合です。
``
form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'), \
                      INPUT(_name='agree',value=True,_type='checkbox'))
form[0].insert(-1,my_extra_element)
``:code

``my_extra_element``変数はフォームスタイルに適合している必要があります。この例では、デフォルトの``formstyle='table3cols'``を想定しています。

サブミット後、``form.vars.agree``はチェックボックスのステータス値を持ち、``onvalidation``関数などで使用できます。

#### データベースIOなしの``SQLFORM``

``SQLFORM``を使用してデータベーステーブルからフォームを生成し、サブミットしたフォームをそのまま検証するが、データベースにおいて自動的なINSERT/UPDATE/DELETEを行いたくない場合があります。たとえば、1つのフィールドが他の入力フィールドから計算される必要がある場合です。また、挿入されたデータに対して標準の検証では達成できない追加の検証を行いたい場合です。

これは、次のものを：
``
form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'
``:code

以下のように分解して簡単に行うことができます。
``
form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
``:code

同じことはUPDATE/DELETEフォームでも行うことができます。次のものを：
``
form = SQLFORM(db.person,record)
if form.process().accepted:
    response.flash = 'record updated'
``:code

以下のように分解します。
``
form = SQLFORM(db.person,record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'
``:code

"upload"型フィールドを持つテーブルの場合でも、``process(dbio=False)``と``validate()``はどちらもアップロードファイルの保存とリネームを、``dbio=True``のように、つまりデフォルトのシナリオのように、処理します。

アップロードされたファイル名は以下にあります：
``
form.vars.fieldname
``:code

### ``SQLFORM.factory``

データベース・テーブルを持っているかのようにフォームを生成したいが、データベース・テーブルはいらないような場面があります。見栄えのよいCSSフレンドリなフォームの生成や、ファイルのアップロードとリネームの実行のために、``SQLFORM``の能力を単純に活用したい場面です。

これは``form_factory``を介して行うことができます。ここに、フォームを生成し、検証を行い、ファイルをアップロードし、すべてを``session``に保存するような例を示します。
``
def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.filename = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

次にビュー"default/form_from_factory.html"を示します：
``
{{extend 'layout.html'}}
{{=form}}
``:code

フィールドのラベルにおいてスペースの代わりにアンダースコアを使用するか、``SQLFORM``で行ったのと同様に、``labels``の辞書を``form_factory``に明示的に渡す必要があります。デフォルトでは、``SQLFORM.factory``は、あたかも"no_table"というテーブルから生成されたフォームのように生成されたhtmlの"id"属性を用いてフォームを生成します。このダミーテーブルの名前を変更したいときは、factoryの``table_name``属性を用いてください：
``
form = SQLFORM.factory(...,table_name='other_dummy_name')
``:code

factoryから生成された2つのフォームを同じテーブルに配置する必要があり、かつ、CSSの競合を避けたい場合、``table_name``の変更が必要になります。

#### 複数テーブルでひとつのフォーム

例えば、参照によってリンクされた'client'と'address'というふたつのテーブルが存在し、顧客とその住所レコードをひとつのフォームで挿入したいとします。これは以下のようにできます：

model:
``
db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client',db.client,writable=False,readable=False),
    Field('street'),Field('city'))
``:code

controller:
``
def register():
    form=SQLFORM.factory(db.client,db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client=id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash='Thanks for filling the form'
    return dict(form=form)
``:code

SQLFORM.factory（両方のテーブルで公開されたフィールドからひとつのフォームを作成しバリデータも継承している）に注意してください。ひとつのフォームの受理で、あるデータはひとつ目のテーブル、残りは別のテーブルからと、ふたつの挿入を実施しています。

-------
複数テーブル間で共通のフィールド名が存在しない場合のみ動作します。
-------

### CRUD
``CRUD``:inxx ``crud.create``:inxx ``crud.update``:inxx ``crud.select``:inxx ``crud.search``:inxx ``crud.tables``:inxx ``crud.delete``:inxx

web2pyに最近追加されたものの1つは、SQLFORMの上にあるCreate/Read/Update/Delete (CRUD) APIです。CRUDはSQLFORMを作成しますが、フォームの作成、フォームの処理、通知、リダイレクトを、すべて1つの関数において補完することによって、コーディングを単純化します。

初めに注意する点は、CRUDが他のこれまで使用してきたweb2pyのAPIと異なり、APIがすでに公開されていないことです。これはインポートしなければなりません。また、特定のデータベースにリンクする必要があります。例:
``
from gluon.tools import Crud
crud = Crud(db)
``:code

上で定義した``crud``オブジェクトは次のようなAPIを提供します：

``crud.tables``:inxx ``crud.create``:inxx ``crud.read``:inxx ``crud.update``:inxx ``crud.delete``:inxx ``crud.select``:inxx .
- ``crud.tables()``は、データベースに定義されているテーブルのリストを返します。
- ``crud.create(db.tablename)``は、テーブルのtablenameに対する作成フォームを返します。
- ``crud.read(db.tablename, id)``は、tablenameとレコードidに対する読み取り専用のフォームを返します。
- ``crud.update(db.tablename, id)``は、tablenameとレコードidに対する更新フォームを返します。
- ``crud.delete(db.tablename, id)``は、レコードを削除します。
- ``crud.select(db.tablename, query)``は、テーブルから選択されたレコードのリストを返します。
- ``crud.search(db.tablename)``は、(form, records)のタプルを返します。formは検索フォームで、recordsはサブミットされた検索フォームに基づくレコードのリストです。
- ``crud()``は、``request.args()``に基づいて、上記のうちの1つを返します。

たとえば、次のアクションは：
``
def data(): return dict(form=crud())
``:code

次のようなURLを公開します：
``
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
``:code

しかし、次のアクションは：

``
def create_tablename():
    return dict(form=crud.create(db.tablename))
``:code

以下の作成メソッドしか公開しません

``
http://.../[app]/[controller]/create_tablename
``:code

また、次のアクションは：

``
def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))
``:code

以下の更新メソッドしか公開しません

``
http://.../[app]/[controller]/update_tablename/[id]
``:code

他も同様です。

CRUDの挙動は二通りの方法でカスタマイズできます。1つは、``crud``オブジェクトにいくつかの属性を設定することです。もう1つは、各メソッドに追加のパラメータを渡すことです。

#### 設定

ここに、現在のCRUD属性と、そのデフォルトの値と、意味のリスト一式を示します：

すべてのcrudのフォームに認証をかけます：

``
crud.settings.auth = auth
``:code
利用方法は第9章で説明します。

``crud``オブジェクトを返す``data``関数を定義しているコントローラを指定します

``
crud.settings.controller = 'default'
``:code

レコードの"create"が成功した後のリダイレクト先のURLを指定します：

``
crud.settings.create_next = URL('index')
``:code

レコードの"update"が成功した後のリダイレクト先のURLを指定します：

``
crud.settings.update_next = URL('index')
``:code

レコードの"delete"が成功した後のリダイレクト先のURLを指定します：

``
crud.settings.delete_next = URL('index')
``:code

アップロードされたファイルへリンクするために使用するURLを指定します：

``
crud.settings.download_url = URL('download')
``:code

``crud.create``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：

``
crud.settings.create_onvalidation = StorageList()
``:code

``StorageList``は``Storage``オブジェクトと同様で、両者"gluon/storage.py"ファイルに定義されていますが、そのデフォルトは``None``ではなく``[]``になります。これにより、次の構文が使用できます：

``
crud.settings.create_onvalidation.mytablename.append(lambda form:....)
``:code

``crud.update``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：

``
crud.settings.update_onvalidation = StorageList()
``:code

``crud.create``フォームの完了後に実行される追加の関数を指定します：

``
crud.settings.create_onaccept = StorageList()
``:code

``crud.update``フォームの完了後に実行される追加の関数を指定します：

``
crud.settings.update_onaccept = StorageList()
``:code

レコードが削除される場合において、``crud.update``の完了後に実行される追加の関数を指定します：

``
crud.settings.update_ondelete = StorageList()
``:code

``crud.delete``の完了後に実行される追加の関数を指定します：

``
crud.settings.delete_onaccept = StorageList()
``:code

"update"フォームが"delete"ボタンを持つかどうかを決めます：

``
crud.settings.update_deletable = True
``:code

"update"フォームが編集レコードの"id"を表示するかどうかを決めます：

``
crud.settings.showid = False
``:code

フォームが前回挿入された値を維持するか、サブミット成功後デフォルトにリセットするかどうかを決めます：

``
crud.settings.keepvalues = False
``:code

crudは編集されているレコードがフォーム表示時からサブミットの間に第3者によって修正されていないかを検知します。これは以下と等しいです。
``
form.process(detect_record_change=True)``

そしてこのように設定します：

``
crud.settings.detect_record_change = True
``:code
変数の値を``False``にすることで無効にすることができます。

フォームのスタイルは次のようにして変更することができます

``
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
``:code

全てのcrudフォームに区切り文字を設定できます。

``
crud.settings.label_separator = ':'
``:code

authで説明されるのと同じやり方で、フォームにキャプチャを加えることができます：

``
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
``:code


#### メッセージ

カスタマイズ可能なメッセージのリストを以下に示します：
``
crud.messages.submit_button = 'Submit'
``:code

これは、create、updateフォーム両方に対して"submit"ボタンのテキストを設定します。
``
crud.messages.delete_label = 'Check to delete:'
``:code

これは、"update"フォームにおいて"delete"ボタンのラベルを設定します。
``
crud.messages.record_created = 'Record Created'
``:code

これは、レコードの作成が成功した際のflashメッセージを設定します。
``
crud.messages.record_updated = 'Record Updated'
``:code

これは、レコードの更新が成功した際のflashメッセージを設定します。
``
crud.messages.record_deleted = 'Record Deleted'
``:code

これは、レコードの削除が成功した際のflashメッセージを設定します。
``
crud.messages.update_log = 'Record %(id)s updated'
``:code

これは、レコードの更新が成功したときのログメッセージを設定します。
``
crud.messages.create_log = 'Record %(id)s created'
``:code

これは、レコードの作成が成功したときのログメッセージを設定します。
``
crud.messages.read_log = 'Record %(id)s read'
``:code

これは、レコードの読み取りアクセスが成功したときのログメッセージを設定します。
``
crud.messages.delete_log = 'Record %(id)s deleted'
``:code

これは、レコードの削除が成功したときのログメッセージを設定します。

なお、``crud.messages``は``gluon.storage.Message``クラスに所属しています。これは、``gluon.storage.Storage``に似ていますが、``T``演算子の必要なしに、自動的にその値を翻訳します。

ログメッセージは、CRUDが第9章で説明するAuthに接続された場合のみ使用されます。イベントは、Authテーブルの"auth_events"にログとして記録されます。

#### メソッド

CRUDのメソッドの挙動は、呼び出し毎の原則でカスタマイズすることができます。ここにその用法を示します：
``
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)
``:code
- ``table``は、DALのテーブル、または、テーブル名です。メソッドはその上で動作します。
- ``record``と``record_id``は、レコードのidです。メソッドはその上で動作します。
- ``next``は、成功後にリダイレクトする先のURLです。URLが部分文字列"[id]"を含む場合、これは、現在作成/更新されたレコードのidによって置換されます。
- ``onvalidation``は、SQLFORM(..., onvalidation)と同じ機能を持ちます。
- ``onaccept``は、フォームのサブミットが受理された後に呼ばれ、そこで、リダイレクトする前に、動作する関数です。
- ``log``はログのメッセージです。CRUDにおけるログのメッセージは、``form.vars``の辞書変数を"%(id)s"のように参照します。
- ``message``はフォームが受理されたときのflashメッセージです。
- ``ondelete``は、"update"フォームを介してレコードが削除されるときに、``onaccept``の場所で呼ばれます。
- ``deletable``は、"update"フォームがdeleteオプションを持つかどうかを決めます。
- ``query``は、レコードを選択するために使用するクエリです。
- ``fields``は、レコードを選択するために使用するクエリです。
- ``orderby``は、選択したレコードの順序を決めます(第6章を参照してください)。
- ``limitby``は、表示される選択レコードの範囲を決めます(第6章を参照してください)。
- ``headers``は、テーブルのヘッダの名前からなる辞書です。
- ``queries``は、``['equals', 'not equal', 'contains']``のようなリストです。検索フォームにおける使用可能なメソッドを保持します。
- ``query_labels``は、``query_labels=dict(equals='Equals')``のような辞書です。検索メソッドに対する名前を与えます。
- ``fields``は、検索ウィジェットにおいて列挙されるフィールドのリストです。
- ``field_labels``は、フィールド名をラベルにマッピングする辞書です。
- ``zero``は、デフォルトでは"choose one"で、検索ウィジェットのドロップダウンのためのデフォルトのオプションとして使用されます。
- ``showall``は最初の呼び出し時にqueryで選択されたrowsを返したい場合はTrueを設定しておきます。（1.98.2以降に追加）
- ``chkall``は検索フォームのチェックボックスを全てチェックしたい時にTrueを設定しておきます。（1.98.2以降に追加）

ここでは、単一のコントローラ関数における使用例を示します：
``
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)
``:code

もう1つのとても汎用的なコントローラ関数を示します。これにより、任意のテーブルから任意のレコードを検索、作成、編集することができます。このとき、テーブル名はrequest.args(0)によって渡されます：
``
def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id, row: \
       A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.search(table)
    return dict(form=form,search=search,rows=rows)
``:code

なお、``table.id.represent=...``の行は、web2pyに対して、idフィールドの表現を変更し、代わりに、自分自身のページへのリンクを表示し、作成ページを更新ページに切り替えるためにidをrequest.args(1)として渡すように指示します。

#### レコードのバージョニング

SQLFORMとCRUDは共にデータベースレコードのバージョニングを行うユーティリティを提供しています：

すべての改訂履歴を必要とするテーブル(db.mytable)を持ちたいなら、次のようにするだけです：
``
form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)
``:code

``
form = crud.update(db.mytable, myrecord, onaccept=auth.archive)
``:code

``auth.archive``は**db.mytable_archive**という新規のテーブルを定義します(この名前は参照するテーブルの名前に由来します)。そして、更新時に、(更新前の)レコードのコピーを、作成した記録用のテーブルに保存します。そのレコードへの参照も含まれます。

レコードは実際に更新されるので(その前回の状態のみが記録されます)、参照が壊れることはありません。

これはすべて内部で行われます。記録テーブルにアクセスしたいならば、モデルにおいてそれを定義しておく必要があります：
``
db.define_table('mytable_archive',
   Field('current_record',db.mytable),
   db.mytable)
``:code

なお、テーブルは``db.mytable``を拡張し(そのすべてのフィールドを含み)、``current_record``へ参照を追加しています。

``auth.archive``は、次のように元のテーブルがtimestampフィールドを持たない限り、保存したレコードのタイムスタンプを取りません。

``
db.define_table('mytable',
    Field('created_on','datetime',
          default=request.now,update=request.now,writable=False),
    Field('created_by',auth.user,
          default=auth.user_id,update=auth.user_id,writable=False),
``:code

これらのフィールドに関して何ら特別なことはなく、好きな名前を付けることが可能です。これらはレコードが記録される前に入力され、各レコードのコピーと共に記録されます。記録テーブルの名前、または/かつ、フィールドの名前は次のように変更することができます：

``
db.define_table('myhistory',
    Field('parent_record',db.mytable),
    db.mytable)
## ...
form = SQLFORM(db.mytable,myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))
``:code

### カスタムフォーム

フォームがSQLFORMやSQLFORM.factory、CRUDを利用して作られている場合、それをビューに埋め込む方法は複数あり、複数の度合いのカスタマイズができるようになります。たとえば次のモデルを考えてみます：
``
db.define_table('image',
    Field('name'),
    Field('file', 'upload'))
``:code

また、次のアップロード・アクションも考えます：
``
def upload_image():
    return dict(form=crud.create(db.image))
``:code

最も簡単に、``upload_image``に対するビューにおいてフォームを埋め込む方法は次の通りです：
``
{{=form}}
``:code

これは標準のテーブル・レイアウトになります。別のレイアウトを使用したい場合、フォームを要素に分解することができます
``
{{=form.custom.begin}}
Image name: <div>{{=form.custom.widget.name}}</div>
Image file: <div>{{=form.custom.widget.file}}</div>
Click here to upload: {{=form.custom.submit}}
{{=form.custom.end}}
``:code

ここで、``form.custom.widget[fieldname]``は、そのフィールドに対して適切なウィジェットにシリアライズされます。フォームがサブミットされてエラーを含む場合、そのエラーは従来通りウィジェットの下に追加されます。

上記のサンプルフォームは下図のように表示されます。

[[image @///image/en6500.png center 300px]]

ただし、同様の結果は次のようにしても得られます：

``
crud.settings.formstyle='table2cols'
``:code

この場合、カスタムフォームを使用していません。他の可能な``formstyle``は、"table3cols" (デフォルト)、"divs"、"ul"です。

web2pyによってシリアライズされたウィジェットを使用したくない場合は、それをHTMLで置き換えることができます。このために有用ないくつかの変数があります：
- ``form.custom.label[fieldname]``はフィールドのラベルを含みます。
- ``form.custom.comment[fieldname]``はフィールドのコメントを含みます。
- ``form.custom.dspval[fieldname]``はフィールドの表示方法に関わるform-typeとfield-typeを含みます。
- ``form.custom.inpval[fieldname]``はフィールドの値に関するform-typeとfield-typeを含みます。

以下に説明する慣例に従うことは重要です。

#### CSSの慣例

SQLFORM、SQLFORM.factory、CRUDによって生成されたフォーム内の​​タグは、フォームのさらなるカスタマイズに使用することができる厳密なCSSの命名規則に従っています。

"mytable"テーブルと"string"型の"myfield"フィールドが与えられたとき、次のものによってレンダリングされます。
``
SQLFORM.widgets.string.widget
``:code

これは次のようになります：
``
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
``:code

以下のことに注意してください：
- INPUTタグのクラスはフィールドの型と同じです。これは"web2py_ajax.html"におけるjQueryのコードが機能するのに非常に重要です。これは、"integer"か"double"のフィールドにおいて数値しか持たないようにし、"time"、"date"、"datetime"のフィールドではポップアップのカレンダーが表示されるようにします。
- idは、クラスの名前とフィールドの名前をアンダースコアで結合したものです。これにより、たとえば``jQuery('#mytable_myfield')``のようにして一意に参照することができ、フィールドのスタイルシートを操作したり、フィールドのイベントに関連付けられたアクション(focus、blur、keyupなど)をバインドすることができるようになります。
- nameは、想像通り、フィールド名になります。

#### エラーの非表示
``hideerror``:inxx

場合によっては、自動的なエラー配置を無効にして、フォームのエラーメッセージをデフォルトではないどこか別の場所に表示したいことがあります。これを行うのは簡単です。

- FORMまたはSQLFORMの場合は、``hideerror=True``を``accepts``メソッドに渡してください。
- CRUDの場合は、``crud.settings.hideerror=True``に設定してください。

エラーを表示するビューを変更したくなることもあります(もはや自動的に表示されないので)。

次の例では、エラーをフォームの中ではなく、フォームの上に表示されるようにしています。
``
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
``:code

エラーは下図のように表示されます：

[[image @///image/en6600.png center 300px]]

このメカニズムはカスタムフォームでも動作します。


### バリデータ
``validators``:inxx

バリデータは入力フィールド(データベース・テーブルから生成されたフォームを含む)を検証するために使用されるクラスです。

``FORM``とともにバリデータを使用する例です：
``
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
``:code

どのようにテーブルのフィールドに対するバリデータを要求するかの例です：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
``:code

バリデータは常にフィールドの``requires``属性を用いて割り当てられます。フィールドは、単一もしくは複数のバリデータを持つことができます。複数のバリデータはリストの一部になります：
``
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
``:code

バリデータは``FORM``上の``accepts``と``process``関数や、フォームを含む他のHTMLヘルパーオブジェクトによって呼ばれます。それらは、列挙されている順序で呼ばれます。

あるフィールドに対して明示的にバリデータを呼ぶこともできます。

``
db.person.name.validate(value)
``

これは``(value,error)``のタプルを返し、検証する値が無い場合は``error``が``None``を返します。

組み込みのバリデータはオプション引数を取るコンストラクタを持っています：

``
IS_NOT_EMPTY(error_message='cannot be empty')
``:code

``error_message``は、任意のバリデータに対してデフォルトのエラーメッセージをオーバーライドするようにします。

データベース・テーブルに対するバリデータの例です：
``
db.person.name.requires = IS_NOT_EMPTY(error_message=T'fill this!')
``:code

ここで、国際化対応のため``T``という翻訳演算子を使用しています。なお、デフォルトのエラーメッセージは翻訳されません。

``list:``型のフィールドに対して使用されるバリデータは以下のみとなります。

- ``IS_IN_DB(...,multiple=True)``
- ``IS_IN_SET(...,multiple=True)``
- ``IS_NOT_EMPTY()``
- ``IS_LIST_OF(...)``

一番最後のバリデータはリスト中の個別要素に対してバリデータを適用します。

#### バリデータ

##### ``IS_ALPHANUMERIC``
``IS_ALPHANUMERIC``:inxx

このバリデータは、フィールドの値がa～z、A～Z、0～9の範囲にある文字しか含まれていないことをチェックします。
``
requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')
``:code

##### ``IS_DATE``
``IS_DATE``:inxx

このバリデータは、指定したフォーマットで有効な日付がフィールドの値に入っていることをチェックします。異なる場所の異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
``
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DATE_IN_RANGE``
``IS_DATE_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
``
requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message='must be YYYY-MM-DD!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DATETIME``
``IS_DATETIME``:inxx

このバリデータは、指定したフォーマットで有効な日時がフィールドの値に入っていることをチェックします。異なる場所の異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
``
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')
``:code

以下のシンボルをフォーマット文字列に対して使用することができます(シンボルと例となる文字列を示します)：
``
%Y  '1963'
%y  '63'
%d  '28'
%m  '08'
%b  'Aug'
%b  'August'
%H  '14'
%I  '02'
%p  'PM'
%M  '30'
%S  '59'
``:code

##### ``IS_DATETIME_IN_RANGE``
``IS_DATETIME_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
``
requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DECIMAL_IN_RANGE``
``IS_DECIMAL_IN_RANGE``:inxx

``
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))
``:code

入力をPythonのDecimalへと変換します。もしくは、数値が指定した範囲に収まっていない場合はエラーを生成します。比較はPythonのDecimalの算術で行われます。

最小値と最大値にはNoneを設定することができ、それぞれ。下限なし、上限なしを意味します。

``dot``引数はオプションで小数を区切る記号を国際化できます。


##### ``IS_EMAIL``
``IS_EMAIL``:inxx

フィールドの値がemailのアドレスのようになっているかをチェックします。確認のためemailを送信することは試みません。
``
requires = IS_EMAIL(error_message='invalid email!')
``:code

##### ``IS_EQUAL_TO``
``IS_EQUEL_TO``:inxx

検証された値が与えられた値(変数にすることもできます)と等しいかチェックします：
``
requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')
``:code

##### ``IS_EXPR``
``IS_EXPR``:inxx

最初の引数は、変数に値に関する論理的な表現を保持する文字列です。フィールドの値を、その式がTrueに評価されるかどうかで検証します。例:
``
requires = IS_EXPR('int(value)%3==0',
                   error_message='not divisible by 3')
``:code

例外が発生しないように、初めに整数であることをチェックしたほうがよいでしょう。
``
requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]
``:code

##### ``IS_FLOAT_IN_RANGE``
``IS_FLOAT_IN_RANGE``:inxx

フィールドの値が範囲内の浮動小数点になっていることをチェックします。次の例では、``0 <= value <= 100``の範囲をチェックしています：
``
requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
         error_message='too small or too large!')
``:code

``dot``引数はオプションで小数を区切る記号を国際化できます。

##### ``IS_INT_IN_RANGE``
``IS_INT_IN_RANGE``:inxx

フィールドの値が範囲内の整数になっていることをチェックします。次の例では、``0 <= value <= 100``の範囲をチェックしています：

``
requires = IS_INT_IN_RANGE(0, 100,
         error_message='too small or too large!')
``:code

##### ``IS_IN_SET``
``IS_IN_SET``:inxx
``multiple``:inxx

フィールドの値がセットに含まれていることをチェックします：
``
requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message='must be a or b or c')
``:code

zero引数は省略可能で、デフォルトで選択されたオプション、つまり、``IS_IN_SET``バリデータ自身によって受理されないオプション、のテキストを決めます。"choose one"オプションを望まない場合は、``zero=None``としてください。

``zero``オプションはリビジョン(1.67.1)において導入されました。これは、アプリケーションを壊さないという意味で後方互換性を破りませんでした。しかし、以前は``zero``オプションがなかったので、その挙動は変化しました。

セットの要素は常に文字列でなければなりません。ただし、このバリデータが``IS_INT_IN_RANGE``(値をintに変換)か``IS_FLOAT_RANGE``(値をfloatに変換)の後に続く場合はその限りではありません。例:
``
requires = [IS_INT_IN_RANGE(0, 8), IS_IN_SET([2, 3, 5, 7],
          error_message='must be prime and less than 10')]
``:code

辞書型やタプルのリストを使ってより記述的なドロップダウンリストを作成することもできます。
``
#### Dictionary example:
requires = IS_IN_SET({'A':'Apple','B':'Banana','C':'Cherry'},zero=None)
#### List of tuples example:
requires = IS_IN_SET([('A','Apple'),('B','Banana'),('C','Cherry')])
``:code


##### ``IS_IN_SET``とタグ付け

``IS_IN_SET``バリデータは``multiple=False``というオプション属性を持ちます。これがTrueに設定されている場合、複数の値を1つのフィールドに格納することができます。フィールドの型は、``list:integer``か``list:string``にしてください。``multiple``参照は、作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。

------
``multiple=True``の場合、``IS_IN_SET``は``zero``や他の値を許可します。つまり、何も選択していないフィールドを許可するということになります。``multiple``はそれぞれ選択できる最小と最大（排他的）である``a``と``b``を持つ、フォーム``(a,b)``のタプルを使用することもできます。
------

##### ``IS_LENGTH``
``IS_LENGTH``:inxx

フィールドの値の長さが与えられた境界の間に収まることをチェックします。テキストとファイルの入力の両方で機能します。

引数は次の通りです：
- maxsize: 最大許容の長さ/サイズ(デフォルトは255)
- minsize: 最小許容の長さ/サイズ

例：テキストの文字列が33文字よりも短いかをチェックします：
``
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
``:code

例：テキストの文字列が5文字よりも長いかをチェックします：
``
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
``:code

アップロードされたファイルのサイズが1KBと1MBの間にあるかをチェックします：
``
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
``:code

ファイルを除くすべてのフィールドの型に対して、値の長さをチェックします。ファイルの場合は、値は``cookie.FieldStorage``になります。したがって、直感的に予想できる挙動であるファイルのデータ長をチェックすることになります。

##### ``IS_LIST_OF``
``IS_LIST_OF``:inxx

これは正確にはバリデータではありません。その使用目的は、複数の値を返すフィールドの検証を可能にすることです。フォームが同じ名前の複数のフィールドや複数選択ボックスを含む場合といった稀なケースにおいて使用されます。唯一の引数は、別のバリデータです。別のバリデータをリストの各要素に適用することしかしません。たとえば、次の式はリストの各項目が0～10の範囲にある整数であることをチェックします：
``
requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))
``:code

これは、エラーを返すことはなく、エラーメッセージも含まれません。内部のバリデータがエラーの発生を制御します。

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータは決してエラーを返しません。単に、値を小文字に変換します。
``
requires = IS_LOWER()
``:code

##### ``IS_MATCH``
``IS_MATCH``:inxx

このバリデータは、値を正規表現と照合し、一致してない場合はエラーを返します。米国の郵便番号を検証する使用例を示します：
``
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
``:code

IPv4アドレスを検証する使用例です(ただし、IS_IPV4バリデータのほうがこの目的のためにはより妥当です)：
``
requires = IS_MATCH('^\d{1,3}(\.\d{1,3}){3}$',
         error_message='not an IP address')
``:code

米国の電話番号を検証するための使用例です：
``
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
``:code

Pythonの正規表現の詳細については、公式のPythonのマニュアルを参照してください。

``IS_MATCH``はデフォルトで``False``に設定されている``strict``というオプションの引数を受け取ります。``True``が設定されている場合は、最初の文字だけを照合します。

``
>>> IS_MATCH('a')('ba')
('ba', <lazyT 'invalid expression'>) # no pass
>>> IS_MATCH('a',strict=False)('ab')
('a', None)                          # pass!
``

``IS_MATCH``はデフォルトで``False``に設定されている``search``というオプションの引数を受け取ります。``True``が設定されている場合は、``match``の代わりに正規表現の``search``を利用して文字を検証します。

##### ``IS_NOT_EMPTY``
``IS_NOT_EMPTY``:inxx

このバリデータは、フィールドの値が空の文字列ではないことをチェックします。
``
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
``:code

##### ``IS_TIME``
``IS_TIME``:inxx

このバリデータは、指定したフォーマットでの有効な時間がフィールドの値に入力されていることをチェックします。
``
requires = IS_TIME(error_message='must be HH:MM:SS!')
``:code

##### ``IS_URL``
``IS_URL``:inxx

次のいずれかに該当するURL文字列を拒否します：
- 文字列が空またはNone
- 文字列がURLで許可されていない文字を使用する
- 文字列がHTTP構文規則のいずれかを破る
- (指定した場合)URLのスキームが'http'か'https'でない
- (ホスト名を指定した場合)トップレベルのドメインが存在しない

(これらの規則は、RFC 2616``RFC2616``:citeに基づいています)

この関数はURLの構文をチェックすることしかしません。たとえば、URLが実際の文章を指しているか、語義的に理にかなっているかはチェックしません。この関数は、省略URL('google.ca'など)の場合、自動的にURLの前に'http://'を追加します。

mode='generic'というパラメータが使用されている場合、この関数の挙動は変化します。このときは、次のいずれかに該当するURL文字列を拒否します：
- 文字列が空またはNone
- 文字列がURLで許可されていない文字を使用する
- (指定した場合)URLのスキームが有効でない

(これらの規則は、RFC 2396``RFC2396``:citeに基づいています)

許可されたスキーマのリストはallowed_schemesパラメータを使用してカスタマイズすることができます。リストからNoneを取り除いた場合、('http'のようなスキームを欠く)省略URLは拒否されます。

デフォルトで先頭に追加されるスキーマはprepend_schemeパラメータでカスタマイズすることができます。prepend_schemeをNoneに設定した場合、先頭への追加は無効になります。それでも、解析のために先頭への追加が必要なURLは受け入れられますが、戻り値は変更されません。

IS_URLは、RFC3490``RFC3490``:citeで指定されている国際化ドメイン名(IDN)の標準と互換性があります。その結果、URLには、通常の文字列またはUnicode文字列を指定できます。URLのドメイン・コンポーネント(たとえば、google.ca)が非US-ASCII文字を含んでいる場合、ドメインは(RFC3492``RFC3492``:citeで定義された)Punycodeに変換されます。IS_URLは標準を少しだけ越えて、非US-ASCII文字がURLのパスとクエリのコンポーネントにも提示されることを許可しています。これらの非US-ASCII文字はエンコードされます。たとえば、スペースは、'％20'にエンコードされます。16進数のUnicode文字0x4e86は'%4e%86'になります。

例：
``
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')
``:code

##### ``IS_SLUG``
``IS_SLUG``:inxx
``
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
``:code

``check``がTrueに設定されている場合、検証される値が(英数字と繰り返しなしのダッシュのみ許可する)スラグかどうかをチェックします。
If ``check`` is set to ``True`` it check whether the validated value is a slug (allowing only alphanumeric characters and non-repeated dashes).

``check``がFalseの場合(デフォルト)、入力値をスラグに変換します。
If ``check`` is set to ``False`` (default) it converts the input value to a slug.

##### ``IS_STRONG``
``IS_STRONG``:inxx

フィールド(通常はパスワードフィールド)の複雑さの要求を強制します。

例：
``
requires = IS_STRONG(min=10, special=2, upper=2)
``:code

ここで、
- minは値の最小の長さです
- specialは要求される特殊文字の最小数です。特殊文字は、次のいずれかなります``@#$%^&*(){}[]-+``
- upperは大文字の最小数です

##### ``IS_IMAGE``
``IS_IMAGE``:inxx

このバリデータは、ファイル入力からアップロードされたファイルが選択した画像のフォーマットの1つで保存されているか、また、与えられた制約内の寸法(幅と高さ)を持っているかどうかをチェックします。

これは、最大ファイルサイズはチェックしていません(そのためにはIS_LENGTHを使用してください)。何もデータがアップロードされていない場合は、検証エラーを返します。BMP、GIF、JPEG、PNGのファイル形式をサポートしています。Python Imaging Libraryは必要ありません。

コードの一部は参照``source1``:citeから取っています。

次の引数を取ります：
- extensions: 許可する小文字の画像ファイル拡張子を保持する反復可能オブジェクト
- maxsize: 画像の最大の幅と高さを保持する反復可能オブジェクト
- minsize: 画像の最小の幅と高さを保持する反復可能オブジェクト

画像サイズのチェックを回避するには、minsizeとして(-1, -1)を使用してください。

いくつかの例を示します：
- アップロードされたファイルがサポートされている画像フォーマットのいずれかに含まれるかをチェックします：
``
requires = IS_IMAGE()
``:code
- アップロードされたファイルがJPEGまたはPNG形式かをチェックします：
``
requires = IS_IMAGE(extensions=('jpeg', 'png'))
``:code

- アップロードされたファイルが最大200x200ピクセルのサイズのPNGであるかをチェックします：
``
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
``:code

- 注記: ``requires = IS_IMAGE()``を含むテーブルの編集フォームを表示している場合、ファイルが削除されると検証を通らないので``delete``チェックボックスが表示されません。``delete``チェックボックスを表示したい場合は次のバリデータを使用してください。
``
requires = IS_EMPTY_OR(IS_IMAGE())
``:code


##### ``IS_UPLOAD_FILENAME``
``IS_UPLOAD_FILENAME``:inxx

このバリデータは、ファイル入力からアップロードされたファイルの名前と拡張子が与えられた条件に一致するかをチェックします。

どのような方法であれ、これはファイルの型を保証するものではありません。何もデータがアップロードされていない場合は、検証エラーを返します。

引数は次の通りです：
- filename: (ドットの前の)ファイル名の正規表現です。
- extension: (ドットの後の)拡張子の正規表現です。
- lastdot: どのドットがファイル名/拡張子の区分に使用されるか：``True``の場合、最後のドットとなります(たとえば、"file.tar.gz"は"file.tar"+"gz"に分解されます)。一方``False``の場合、最初のドットになります(たとえば、"file.tar.gz"は"file"+"tar.gz"に分解されます)。
- case: 0は大文字小文字を維持します。1は文字列を小文字に変換します(デフォルト)。2は文字列を大文字に変換します。

dotが存在しない場合、拡張子は空の文字列に対してチェックされ、ファイル名はすべての文字列に対してチェックされます。

例：

ファイルがpdfの拡張子を持つかをチェックします(大文字小文字は区別しません)：
``
requires = IS_UPLOAD_FILENAME(extension='pdf')
``:code

ファイルがtar.gz拡張子を持ち、かつ、backupで始まる名前を持つかをチェックします：
``
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
``:code

ファイルが、拡張子を持たず、かつ、名前がREADMEに一致するかをチェックします(大文字小文字を区別します)：
``
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
``:code

##### ``IS_IPV4``
``IS_IPV4``:inxx

このバリデータは、フィールドの値が10進数形式のIPバージョン4のアドレスかをチェックします。特定の範囲のアドレスに強制するように設定できます。

IPv4の正規表現は参照``regexlib``:citeから取っています。
引数は以下の通りです。
- ``minip``許容する最下限のアドレス。str(例：192.168.0.1)や、反復可能な数字(例：[192, 168, 0, 1])や、int(例：3232235521)を受け入れます。
- ``maxip``許容する最上限のアドレス。上と同様に受け入れます。

ここにある3つの例の値は同じです。アドレスは、次の関数で包含チェックをするために、整数に変換されるからです：
``
number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]
``:code

例：

有効なIPv4のアドレスに対するチェックをします：
``
requires = IS_IPV4()
``:code

有効なプライベートネットワークのIPv4のアドレスに対するチェックをします：
``
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
``:code

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータはエラーを返すことはありません。値を小文字に変換します。
``
requires = IS_LOWER()
``:code

##### ``IS_UPPER``
``IS_UPPER``:inxx

このバリデータはエラーを返すことはありません。値を大文字に変換します。
``
requires = IS_UPPER()
``:code

##### ``IS_NULL_OR``
``IS_NULL_OR``:inxx

現在のバージョンでは使用されておらず、下に記述する``IS_EMPTY_OR``の別名です。

##### ``IS_EMPTY_OR``
``IS_EMPTY_OR``:inxx

他の要求を満たしつつフィールドに空の値を許可したい場合があります。たとえば、フィールドは日付だが、空の値にもなりうるという場合です。``IS_EMPTY_OR``バリデータはこれを可能にします：
``
requires = IS_EMPTY_OR(IS_DATE())
``:code

##### ``CLEANUP``
``CLEANUP``:inxx

これはフィルタです。失敗することはありません。単に、[10、13、32〜127]のリストに含まれない10進数のASCIIコードを持つすべての文字を削除します。
``
requires = CLEANUP()
``:code

##### ``CRYPT``
``CRYPT``:inxx

これもフィルタです。入力に対して安全なハッシュを実行します。パスワードがデータベースにそのまま渡されるのを防ぐのに使用されます。
``
requires = CRYPT()
``:code

keyが指定されていない場合、MD5アルゴリズムが使用されます。keyが指定されている場合、CRYPTはHMACアルゴリズムを用います。keyには、HMACとともに使用するアルゴリズムを決める接頭辞を含めることも可能です。たとえば、SHA512は次のようになります：

``
requires = CRYPT(key='sha512:thisisthekey')
``:code

これは、推奨される構文です。keyは、使用されるデータベースに関連付けられた一意の文字列でなければなりません。keyは変更することはできません。keyを失うと、それ以前にハッシュ化された値は使用できなくなります。

CRYPTバリデータは入力をハッシュ化するので、ある意味特別な処理と言えます。ハッシュ化される前にパスワードフィールドを検証したい場合は、CRYPTをバリデータのリストに入れることで可能ですが、最後に呼ばれるようにするために、リストの一番最後に追加する必要があります。例:

``
requires = [IS_STRONG(),CRYPT(key='sha512:thisisthekey')]
``:code

``CRYPT``はデフォルト値がゼロである``min_length``引数を取ることもできます。

#### データベースのバリデータ

##### ``IS_NOT_IN_DB``
``IS_NOT_IN_DB``:inxx

次の例を考えます：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

これは、新規のpersonを挿入したとき、彼/彼女の名前がデータベース``db``のフィールド``person.name``にすでに存在していないことを要求します。他のバリデータと同様、この要求はフォーム処理のレベルで強制され、データベースレベルではされません。これには次のわずかな可能性があります。2人の訪問者が同時に、同じperson.nameを持つレコードを挿入しようとした場合、競合状態を引き起こし、両者のレコードが受け入れられてしまうことです。したがって、データベースに対しても、このフィールドが一意の値を持つということを知らせるほうが安全です：
``
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

このとき、競合状態が発生した場合、データベースはOperationalErrorを発生させ、2つのうちの1つの挿入が拒否されます。

``IS_NOT_IN_DB``の最初の引数は、データベース接続かSetにすることができます。後者の場合、Setで定義されたセットのみをチェックするようになります。

例えば次のコードは、10日以内に同じ名前を持つ2人のpersonsの登録を許可しません：
``
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp>now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
``:code

##### ``IS_IN_DB``
``IS_IN_DB``:inxx

次のテーブルと要求を考えてください：

``
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
``:code

これは、dogの挿入/更新/削除フォームのレベルで強制されます。これは、``dog.owner``が``db``データベースの``person.id``フィールドにおいて有効なidになっていることを要求します。このバリデータのおかげで、``dog.owner``フィールドはドロップボックスによって表現されます。バリデータの3番目の引数は、ドロップボックスの内の要素を説明する文字列です。この例では、personの``%(id)s``の代わりに、personの``%(name)s``を見たいことになります。%(...)sは、各レコードに対して括弧内においてフィールドの値によって置き換えられます。

``zero``オプションは``IS_IN_SET``バリデータに対するものと非常によく似た動作をします。

バリデータの最初の引数は``IS_NOT_IN_DB``のようにデータベース接続やDALセットも使用できます。これはドロップボックスのレコードを制限したい場合などに活用できます。次の例では、コントローラが呼ばれるたびに動的にレコードを制限するように``IS_IN_DB``を使用しています。

``
def index():
    (...)
    query = (db.table.field == 'xyz') #in practice 'xyz' would be a variable
    db.table.field.requires=IS_IN_DB(db(query),....)
    form=SQLFORM(...)
    if form.process().accepted: ...
    (...)
``:code

フィールドの検証はしたいが、ドロップボックスを表示したくない場合、バリデータをリストの中に置いてください。

``
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
``:code

``_and``:inxx
場合によっては、ドロップボックスは使用したい(上のようにはリスト構文を用いたくない)が、追加のバリデータを使用したいときがあります。この目的のために、``IS_IN_DB``バリデータは``_and``という追加の引数をとります。これは、検証値が``IS_IN_DB``の検証を通った場合に適用される他のバリデータのリストを指します。たとえば、db内のすべてのdogのownersにおいて、あるサブセットにはないことを検証するためには次のようにします：
``
subset=db(db.person.id>100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))
``:code

``IS_IN_DB``はselectの``cache``引数と同じような``cache``引数も取ります。

##### ``IS_IN_DB``とタグ付け
``tags``:inxx
``multiple``:inxx

``IS_IN_DB``バリデータは、``multiple=False``というオプション属性を持ちます。これが``True``に設定されている場合、複数の値が1つのフィールドに保存されます。このフィールドは、第6章で説明した``list:reference``型にする必要があります。そこでは、明示的なタグ付けの例が説明されています。``multiple``の参照は作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。

#### カスタムバリデータ
``custom validator``:inxx

すべてのバリデータは、以下のプロトタイプに従っています：
``
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
``:code

すなわち、値を検証するために呼ばれたとき、バリデータは``(x, y)``というタプルを返します。``y``が``None``の場合、値は検証を通過し、``x``は通過した値を保持します。たとえば、バリデータが値に整数であることを要求する場合、``x``は``int(value)``に変換されます。値が検証を通過しない場合は、``x``は入力値を保持し、``y``は検証の失敗を説明するエラーメッセージを保持します。このエラーメッセージは、値が妥当でないフォームにエラーを報告するために使用されます。

バリデータは``formatter``メソッドも持つことが可能です。これは、``__call__``が行うものと逆の変換を行う必要があります。たとえば、``IS_DATE``に対するソースコードを考えてみます：
``
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
``:code

成功した場合、 ``__call__``メソッドはフォームからデータ文字列を読み取り、コンストラクタで指定したフォーマット文字列を用いてそれをdatetime.dateオブジェクトに変換します。``formatter``オブジェクトは、datetime.dateオブジェクトを受け取り、同じフォーマットを用いてそれを文字列表現に変換します。``formatter``はフォームによって自動的に呼び出されます。しかし、明示的に使用して、オブジェクトを適切な表現に変換することもできます。例:
``
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.formatter(row.birth)
01/01/2008
``:code

複数のバリデータが要求(リストに格納)されたとき、それらは順序通りに実行され、1つの出力は入力として次のものへ渡されます。この連鎖は、バリデータのいずれかが失敗したときに中断されます。

反対に、フィールドの``formatter``メソッドを呼ぶとき、複数のバリデータに関連付けられたformattersもまた連鎖されますが、逆順になります。

------
カスタムバリデータの代わりに``form.accepts(...)``、``form.process(...)``、``form.validate(...)``の要素である``onvalidate``を使用することもできます。
------


#### 依存関係のバリデータ

通常、バリデータは全てのモデル内で一度だけ設定されます。

フィールドを検証する必要があり、その検証が別のフィールドの値に依存することがあります。これはいろいろな方法で実現できます。モデルで実現する方法とコントローラで実現する方法があります。

例として、ユーザー名と2度のパスワードを尋ねる登録フォームを生成するページを示します。どのフィールドも空にすることはできず、両者のパスワードは一致しなければなりません：
``
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)
``:code

同じメカニズムは、FORMとSQLFORMオブジェクトに適用することができます。

### Widgets

以下に利用可能なweb2pyのウィジェットの一覧を示します：
``
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
``:code

最初の10個は対応するフィールド型のデフォルトになります。"options"ウィジェットは、フィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=False``(デフォルトの挙動)のときに使用されます。"multiple"ウィジェットはフィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=True``のときに使用されます。"radio"と"checkboxes"ウィジェットはデフォルトでは決して使用されませんが、手動で設定することができます。autocompleteウィジェットは特別で、それ自身のセクションで説明します。

たとえば、textareaで表示される"文字列"フィールドを持つには以下のようにします：
``
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
``:code

ウィジェットをフィールドに''帰納的に''割り当てることもできます:

``
db.mytable.myfield.widget = SQLFORM.widgets.string.widget
``

ウィジェットは値が指定される必要がある追加の引数を取る場合があります。この場合、``lambda``を使用できます。

``
db.mytable.myfield.widget = lambda field,value: \
    SQLFORM.widgets.string.widget(field,value,_style='color:blue')
``

ウィジェットはヘルパファクトリで、最初の2つの引数は常に``field``と``value``です。他の引数には通常のヘルパの属性である``_style``や``_class``等を含みます。特別な引数を取るウィジェットもあります。具体的にいうと、``SQLFORM.widgets.radio``や``SQLFORM.widgets.checkboxes``はそれを格納するフォームの``formstyle``と適合するために、"table"、"ul"、"divs"を指定できる``style``引数（``_style``と混同しないでください）を取ることができます。

新しいウィジェットを作成したり、既存のウィジェットを拡張したりすることができます。

``SQLFORM.widgets[type]``はクラスで、``SQLFORM.widgets[type].widget``は対応するクラスの静的メンバ関数です。各ウィジェット関数は2つの引数をとります。フィールドオブジェクトと現在のフィールドの値です。これは、ウィジェットの表現を返します。例として、stringウィジェットは次のように再コード化することができます：
``
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
``:code

idとclassの値は、本章の後半で説明されている慣例に従う必要があります。ウィジェットは独自のバリデータを持つことが可能ですが、バリデータをフィールドの"requires"属性に関連付け、ウィジェットがそこからそれらを得るようにするのが良いプラクティスです。

#### Autocomplete widget
``autocomplete``:inxx

autocompleteウィジェットには2つの使い道があります：リストから値を受けてフィールドを自動補完するためと、参照フィールドを自動補完するためです(ここで自動補完される文字列はidのように実装された参照の表現です)。

最初のケースは簡単です：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)
``:code

ここで、``limitby``は一度に10個までの候補しか表示しないようにウィジェットに指示します。``min_length``は、ユーザーが検索ボックスにおいて少なくとも2文字をタイプした後のみ、候補を取得するAjaxコールバックを実行するようにウィジェットに指示します。

2番目のケースはより複雑になります：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
``:code

この場合、``id_field``の値は、自動補完される値が``db.category.name``でも、保存される値は対応する``db.category.id``になるようにウィジェットに指示します。オプションのパラメタ``orderby``は、候補をどのようにソートするかをウィジェットに指示します(デフォルトはアルファベット順です)。

このウィジェットは、Ajaxを介して動作します。ここで、Ajaxコールバックはどこにあるのでしょうか？いくつかの魔法が、このウィジェットで起こっています。コールバックはウィジェットオブジェクトのメソッドそのものです。どのように公開されているのでしょうか？web2pyにおいて、任意のコード断片はHTTP例外を発生させることによってレスポンスを生成することができます。このウィジェットは次の方法でこの可能性を利用しています：ウィジェットはAjax呼び出しを最初にウィジェットを生成したURLと同じところに送ります。そして、request.varsにおいて特別なトークンを置きます。ウィジェットは再びインスタンス化されるはずで、ウィジェットはそのトークンを見つけ、リクエストに応答するHTTP例外を発生させます。これらすべては内部で行われ、開発者に対して隠されています。

### ``SQLFORM.grid``と``SQLFORM.smartgrid`` (実験的)

複雑なCRUDコントロールを作成する2つの高機能なガジェットがあります。レコードのページ送り、表示、検索、ソート、作成、更新、削除を1つのガジェットから実行する機能を提供します。

``SQLFORM.grid``の方がシンプルです。ここに使用方法の例を挙げます:

``
@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()
``
これは次のページを作成します。

[[image @///image/en6700.png center 480px]]

``SQLFORM.grid``の最初の引数はテーブル名かクエリです。gridガジェットはクエリに適合したレコードに対する接続を提供します。

gridガジェットの膨大な引数のリストの説明の前に、どのように動作するかを理解する必要があります。ガジェットは``request.args``を参照し何の動作（表示、検索、作成、更新、削除等）をするか決定します。ガジェットで作成されたそれぞれのボタンは同じ関数（上記の場合は``manage_users``）にリンクされますが、異なる``request.args``を渡します。gridによって作成されたURLは全てデフォルトで電子署名され認証されています。これはユーザーがログインしていない場合、一部の機能（作成、更新、削除）が実行できないことを意味します。この制限については緩和することができます。

``
def manage_users():
    grid = SQLFORM.grid(db.auth_user,user_signature=False)
    return locals()
``

しかし、これは推奨されません。

-----
``LOAD``を利用してコンポーネントとして埋め込みでもしない限り、gridはコントローラの関数につきひとつしか使用できないからです。
-----

gridを含む関数自体がコマンドライン引数を操作する場合があるので、gridはどの引数をgridで処理し、どの引数をgrid以外で処理するかを把握する必要があります。例えば、これは任意のテーブルを処理できるコードの例です。

``
@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table],args=request.args[:1])
    return locals()
``
``grid``の``args``引数はどの``request.args``がガジェットに渡されるか若しくは無視されるかを指定します。私たちの例では``request.args[:1]``は処理したいテーブル名を表し、ガジェットではなく、``manage``関数自体で扱われています。

gridの完全な用法は次のようになります:

``
SQLFORM.grid(query,
             fields=None,
             field_id=None,
             left=None,
             headers={},
             orderby=None,
             searchable=True,
             sortable=True,
             deletable=True,
             editable=True,
             details=True,
             create=True,
             csv=True,
             paginate=20,
             selectable=None,
             links=None,
             upload = '<default>',
             args=[],
             user_signature = True,
             maxtextlengths={},
             maxtextlength=20,
             onvalidation=None,
             oncreate=None,
             onupdate=None,
             ondelete=None,
             sorter_icons=('[^]','[v]'),
             ui = 'web2py',
             showbuttontext=True,
             search_widget='default',
             _class="web2py_grid",
             formname='web2py_grid',
             ignore_rw = False,
             formstyle = 'table3cols'):
``:code

- ``fields`` はデータベースから取得されるフィールドのリストです。gridビューにどのフィールドを表示するかを決定するためにも使用されます。
- ``field_id`` は``db.mytable.id``のように、IDとして使用されるテーブルのフィールドである必要があります。
- ``headers`` は'tablename.fieldname'を対応するヘッダーラベルにマッピングする辞書です。
- ``left`` は``...select(left=...)``によって左外部結合を定義したい場合に利用する追加の記述です。
- ``orderby`` はrowsのデフォルトでの表示順序に使用します。
- ``searchable``,``sortable``, ``deletable``, ``details``, ``create`` は検索、ソート、削除、詳細表示、新規レコード作成を実行できるかどうかそれぞれ決定します。
- ``csv`` trueの場合はCSV形式でgridをダウンロードできます。
- ``paginate`` は各ページのrowsの最大値を指定します。
- ``links`` は異なるページにリンクできる新しい項目を表示するのに使用されます。``links``変数は``dict(header='name',body=lambda row: A(...))``のリストを取る必要があります。``header``は新しい項目のヘッダーで、``body``はrowを取得し値を返します。この例でいうとその値は``A(...)``ヘルパになります。
- ``maxtextlength`` はgridビュー上で表示される各フィールドの文字の最大長を設定します。この値は'tablename.fieldname':lengthの辞書として``maxtextlengths``を利用し上書くことができます。
- ``onvalidation``, ``oncreate``, ``onupdate``,``ondelete`` はコールバック関数です。``ondelete``はフォームオブジェクトを入力値として受け取ります。
- ``sorter_icons`` は各フィールドの昇順、降順ソートオプションを表示するふたつの文字（またはヘルパ）のリストです。
- ``ui`` は'web2py'と同様にweb2py形式のクラス名を設定します。``jquery-ui``はjquery UI形式のクラス名を設定しますが、様々なgridコンポーネントにおいて独自のクラスも設定されます。

``
ui = dict(widget='',
          header='',
          content='',
          default='',
          cornerall='',
          cornertop='',
          cornerbottom='',
          button='button',
          buttontext='buttontext button',
          buttonadd='icon plus',
          buttonback='icon leftarrow',
          buttonexport='icon downarrow',
          buttondelete='icon trash',
          buttonedit='icon pen',
          buttontable='icon rightarrow',
          buttonview='icon magnifier')
``:code

- ``search_widget`` はデフォルトの検索ウィジェットを上書くことができます。詳細は"gluon/sqlhtml.py"のソースコードを参照してください。
- ``showbutton`` 全てのボタンを非表示にできます。
- ``_class`` はgridコンテナのクラスです。
- ``formname``, ``ignore_rw``, ``formstyle`` は作成/更新フォーム用のgridで使用されるSQLFORMオブジェクトに渡されます。

------
``deletable``, ``editable``, ``details`` は一般的にブーリアンの値ですが、rowオブジェクトを取得し対応するボタンを表示・非表示するか決定するといった関数も使用できます。
-----
``SQLFORM.smartgrid``は``grid``に非常によく似ています。実際にgridを含みますが、クエリではなくひとつのテーブルを入力として受け取るように設計されています。そして参照先のテーブルも表示します。

以下のテーブル構造を考えてみましょう:

``
db.define_table('parent',Field('name'))
db.define_table('child',Field('name'),Field('parent','reference parent'))
``:code

SQLFORM.gridで全ての親を一覧表示できます:

``
SQLFORM.grid(db.parent)
``:code
全ての子供:
``
SQLFORM.grid(db.child)
``:code
全ての親と子供をひとつのテーブル:
``
SQLFORM.grid(db.parent,left=db.child.on(db.child.parent=db.parent.id))
``:code

SQLFORM.smartgridで全てのデータをまとめたひとつのガジェットを作成し、両方のテーブルを出力できます。

``
@auth.requires_login():
def manage():
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

以下のようになります:

[[image @///image/en6800.png center 480px]]

"children"リンクが追加されています。通常の``grid``を利用して追加の``links``を作成することもできますがその場合は異なる機能を示しています。``smartgrid``を利用することで自動的に作成され同じガジェットで処理されます。

また、ある親の"children"リンクをクリックするとその親に紐づく（これは明らかですが）子供だけのリストが取得できます。しかし、新しい子供を追加しようとすると、その子供の親の値は選択された親（ガジェットに関連するパンくずリストで表示）から自動的に設定されます。そのフィールドの親の値は上書くこともできます。読み取り専用にすることで上書きを防げます。

``
@auth.requires_login():
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

``linked_tables``引数が指定されていない場合は全ての参照テーブルが自動的にリンクされます。どちらにせよ、誤ってデータが公開されないように、リンクされるべきテーブルの一覧を明示的に指定することを推奨します。

次のコードはシステム内の全てのテーブルの非常に強力な管理インターフェースを作成します。

``
@auth.requires_membership('managers'):
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table],args=request.args[:1])
    return locals()
``:code

``smartgrid``は``grid``と同じ引数を取り、条件付で追加の引数も取ります。

- 最初の引数はテーブルで、クエリではありません
- 'tablename':queryの辞書である``constraints``という追加の引数があります。これは'tablename'gridで表示されるレコードに対してさらなるアクセス制限をかけることができます。
- smartgridから接続できるテーブルの名称リストである``linked_tables``という追加の引数があります。
- 以下で説明するようにテーブル、``args``、``linked_tables``、``user_signatures``に辞書型を使うことができます。

前回のgridを考えて見ましょう:
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
``

``db.parent``と``db.child``の両方に接続できます。ナビゲーションコントロールにとって、それぞれのテーブルは、スマートテーブルではなくただのgridです。この場合、これはひとつのsmartgridが親と子供のgridをひとつずつ作成できることを意味します。これらのgridに異なるパラメタのセットを渡すこともできます。例えば異なる``searchable``パラメタのセットです。

gridではブーリアン型を渡せます:
``
grid = SQLFORM.grid(db.parent,searchable=True)
``
smartgridではブーリアン型の辞書を渡せます:
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'],
     searchable= dict(parent=True, child=False))
``
このように親は検索可能だが子供は検索不可（検索ウィジェットが必要な場合はあまり多くないです）にできます。


-------
gridとsmartgridは今後も残りますが実験的としています。これは新たな機能追加があった場合に、返される実際のhtmlレイアウトやパラメータのセットが変更される可能性があるからです。
-------


``grid``と``smartgrid``はcrudのように自動でアクセス権を強制しませんが、``auth``と統合して明示的にパーミッションを確認することができます:

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))
``

または

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit','auth_user'),
     deletable = auth.has_permission('delete','auth_user'))
``

``smartgrid``は単数形と複数形の両方のテーブル名を表示する唯一のweb2pyのガジェットです。例えばparentは一人の"Child"や、たくさんの"Children"を持てます。それゆえ、テーブルオブジェクトは自身の単数形と複数形の名称を知る必要があります。web2pyは通常これを予測しますが明示的に設定することもできます:

``
db.define_table('child', ..., singular="Child", plural="Children")
``:code

または: ``singular``:inxx ``plural``:inxx

``
db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"
``:code

``T``演算子を使用して国際化対応することもできます。

そして複数形と単数形の値は``smartgrid``で使用されるヘッダーとリンクの正しい名前として提供されます；。

##### 第3版 - 翻訳: 細田謙二　レビュー: Omi Chiba
##### 第4版 - 翻訳: Omi Chiba　レビュー: Fumito Mizuno
