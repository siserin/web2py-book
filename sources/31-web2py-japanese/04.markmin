## コア

### コマンドライン オプション

GUIを表示せずにweb2pyを開始させるには、コマンドラインから次のように入力します：
``password``:inxx

``
python web2py.py -a 'your password' -i 127.0.0.1 -p 8000
``:code

web2pyが起動すると、パスワードのハッシュ値を保存する場所として"parameters_8000.py"ファイルが作成されます。"<ask>"をパスワードとして入力すると、パスワードを入力するプロンプトが表示されます。

セキュリティ向上のため、次のようにweb2pyを起動することができます：
``
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
``:code

この場合、web2pyは以前に保存したパスワードのハッシュ値を再利用します。パスワードが提供されていない場合、つまり、"parameters_8000.py"ファイルが削除されていた場合は、Webベースの管理インターフェイスは無効になります。

``PAM``:inxx
いくつかのUnix / Linuxシステムでは、次のようにパスワードを指定すると、
``
<pam_user:some_user>
``:code

管理者認証のために用いられる``some_user``のオペレーティングシステムアカウントのPAMパスワードが、PAMの設定でブロックしていない限り、使用されます。

-------
web2pyは通常CPython(Guido van Rossumによって作成されたC言語で実装されたPython)で動作します。しかしJython(Javaによる実装)でも動作できます。後者によって、J2EE上でweb2pyを動かせることができるかもしれません。Jythonを使うには、単に"python web2py.py ..."を"jython web2py.py"と置き換えるだけです。Jythonのインストールの詳細、データベースのアクセスに必要なzxJDBCモジュールは、第12章で説明します。
-------

"web2py.py"スクリプトは、多くのコマンドライン引数を取ることができます。その中には、スレッドの最大数やSSLの有効化などがあります。以下はその一通りのリストです：

``command line``:inxx
``
>>> python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        ip address of the server (127.0.0.1)
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration
                        use -a "<recycle>" to reuse the last
                        password
  -u UPGRADE, --upgrade=UPGRADE
                        -u yes: upgrade applications and exit
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  -f FOLDER, --folder=FOLDER
                        folder from which to run web2py
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all,
                        100 means none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython
                        (if installed) with specified appname
  -P, --plain           only use plain python shell; should be used
                        with --shell option
  -M, --import_models   auto import model files; default is False;
                        should be used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment;
                        should be used with --shell option
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment;
                        TEST_PATH like a/c/f (c,f optional)
  -W WINSERVICE, --winservice=WINSERVICE
                        -W install|start|stop as Windows service
  -C, --cron            trigger a cron run manually; usually invoked
                        from a system crontab
  -N, --no-cron         do not start cron automatically
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar
                        (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --interfaces=INTERFACES
                        allows multiple interfaces to be served
``:code

小文字のオプションは、Webサーバーを設定するために使用されます。-Lオプションは設定オプションをファイルから読み込むようにします。``-W``はweb2pyをWindowsサービスとしてインストールします。``-S``、``-P``、``-M``オプションは、インタラクティブなPythonのシェルを開始します。``-T``オプションは、web2pyの実行環境にあるコントローラのdoctestを探し、実行します。次の例は、"welcome"アプリケーションのすべてのコントローラのdoctestを実行します：
``
python web2py.py -vT welcome
``:code

web2pyをWindowsサービスとして実行している場合（``-W``オプション）、コマンドライン引数から設定を行うのは手間がかかります。このため、web2pyのフォルダには、サンプルとして"options_std.py"が内部Webサーバーの設定ファイルとして用意されています：

``
import socket, os
ip = '127.0.0.1'
port = 8000
password = '<recycle>' ### <recycle> means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
ssl_certificate = " ### path to certificate file
ssl_private_key = " ### path to private key file
numthreads = 10
server_name = socket.gethostname()
request_queue_size = 5
timeout = 10
shutdown_timeout = 5
folder = os.getcwd()
``:code

このファイルには、web2pyのデフォルト値が含まれています。このファイルを編集した場合、``-L``コマンドラインオプションを用いて明示的にインポートする必要があります。なお、これはweb2pyをWindowsサービスとして動作させた場合のみ機能します。

### ディスパッチ
``url mapping``:inxx ``dispatching``:inxx

web2py maps a URL of the form:

``
http://127.0.0.1:8000/a/c/f.html
``:code

"a"というアプリケーションの"c.py"というコントローラの``f()``関数に割り当てます。もし``f``が提示されていない場合、``index``というコントローラの関数がデフォルトとして使用されます。``c``が提示されていない場合は、"default.py"がコントローラがデフォルトとして使用されます。aが提示されていない場合は、``init``というアプリケーションがデフォルトとして使用されます。``init``というアプリケーションがない場合、web2pyはwelcomeというアプリケーションの実行を試みます。下の画像は、この内容を模式的に示したものです：

(デフォルトのアプリケーション、コントローラ、関数の名前は、routes.pyにて書き換えることができます; 後述の''[[デフォルトアプリケーション、コントローラ、関数 #Default-Application,-Controller-and-Function]]''を参照してください。

[[image @///image/en6400.png center 480px]]

デフォルトでは、任意の新しいリクエストはまた、新しいセッションを作成します。加えて、セッション・クッキーは、セッションを維持するためにクライアントのブラウザに返されます。

拡張子``.html``は省略できます。その場合``.html``がデフォルトとして仮定されます。この拡張子はビューの拡張子を決定します。ここでビューはコントローラ関数``f()``の出力をレンダリングするものです。拡張子によって、同じコンテンツを複数の形式(HTML、XML、JSON、RSSフィードなど)で提供することができます。

-------
引数をとる関数や、2つのアンダースコアで始まる関数は一般には公開されず、他の関数からしか呼び出すことができません。
-------

``static files``:inxx
URLの形式では、次のような例外があります。
``
http://127.0.0.1:8000/a/static/filename
``:code

ここで、"static"というコントローラは存在しません。web2pyはこれを、"a"というアプリケーションの"static"というサブフォルダにある"filename"という名前のファイルへのリクエストとして解釈します。

``PARTIAL CONTENT``:inxx ``IF_MODIFIED_SINCE``:inxx
静的ファイルをダウンロードするとき、web2pyはセッションを作成せず、クッキーを発行したりモデルを実行することもありません。web2pyは常に静的ファイルを1MBごとに分割して、PARTIAL CONTENT を送信します。このとき、クライアントは分割ファイルに対してRANGEリクエストを送ることになります。

web2pyはまた、IF_MODIFIED_SINCEプロトコルもサポートしています。ファイルがすでにブラウザに保存されていて、そのファイルが現在のバージョンから変更されていない場合、ファイルは送信されません。

``request.application``:inxx ``request.controller``:inxx ``request.function``:inxx ``GET``:inxx ``POST``:inxx ``request.args``:inxx
web2pyは、次のような形式のGET/POSTのリクエストを：
``
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
``:code

``a``アプリケーションの"c.py"というコントローラの関数``f``に割り当て、URLのパラメータを``request``変数に次のように保存します：
``
request.args = ['x', 'y', 'z']
``:code

and:
``
request.vars = {'p':1, 'q':2}
``:code

and:
``
request.application = 'a'
request.controller = 'c'
request.function = 'f'
``:code

上記の例では、``request.args[i]``と``request.args(i)``はいずれも、``request.args``のi番目の要素を取得します。しかし前者は、request.argsにi番目の要素がない場合に例外が発生します。後者はNoneを返します。

``request.url``:inxx
``
request.url
``:code

これは、現在のリクエストに対する完全なURL(ただしGET変数は含まれない)を格納します。

``request.ajax``:inxx ``request.cid``:inxx

``
request.ajax
``:code

これはデフォルトでFalseですが、Ajaxリクエストでアクションが呼ばれたとweb2pyが判断した場合にはTrueになります。

リクエストがAjaxで、web2pyコンポーネントによって引き起こされたものであれば、そのコンポーネントの名前は次のものから知ることができます：

``
request.cid
``:code

コンポーネントについては、第13章で詳しく説明します。

``request.get_vars``:inxx ``request.post_vars``:inxx ``request.vars``:inxx
HTTPリクエストがGETである場合、``request.env.request_method``には"GET"が設定されます。POSTの場合、``request.env.request_method``には"POST"が設定されます。URLのクエリ変数は``request.vars``のStorage辞書として格納されます。それらの値は``request.get_vars``(GETリクエストの場合)または、``request.post_vars``(POSTリクエストの場合)にも格納されます。

WSGIとweb2pyの環境変数は``request.env``に、次の例のように格納されます：
``
request.env.path_info = 'a/c/f'
``:code

また、HTTPヘッダを環境変数に次のように格納します：
``
request.env.http_host = '127.0.0.1:8000'
``:code

-------
web2pyはすべてのURLに対して、ディレクトリトラバーサル攻撃を防ぐために検証を行っています。
-------

URLは、英数字、アンダースコア、スラッシュのみでしか構成されません。ただし、``args``は連続しないドットを含むこともあります。空白文字は、検証の前にアンダースコアに置き換えられます。URL構文が無効な場合は、HTTP 400エラーメッセージ``http:w,http:o``:citeを返します。

URLが静的ファイルへのリクエストに一致する場合、web2pyは要求されたファイルを単純に読み込んで返します(ストリーミングします)。

URLが静的ファイルへのリクエストでなかった場合、web2pyはリクエストを次の順序で処理します：
- クッキーを解析します。
- 関数が実行される環境を作成します。
- ``request``、``response``、``cache``を初期化します。
- 既存の``session``を開くか、新しいものを作成します。
- リクエストされたアプリケーションに属するモデルを実行します。
- リクエストされたコントローラのアクション関数を実行します。
- 関数が辞書を返す場合、関連付けられたビューを実行します。
- 成功した場合、すべての開いているトランザクションをコミットします。
- セッションを保存します。
- HTTPレスポンスを返します。

コントローラとビューは同じ環境の異なるコピーで実行されることに注意してください。したがって、ビューはコントローラを参照しません。代わりに、モデル、および、コントローラのアクション関数によって返された変数を、参照します。

(HTTP以外の)例外が発生した場合、web2pyは次の処理を行います：
- トレースバックをエラーファイルに格納し、チケット番号をそれに割り当てます。
- すべての開いているトランザクションをロールバックします。
- チケット番号を載せたエラーページを返します。

例外が``HTTP``例外の場合、意図した動作(たとえば``HTTP``のリダイレクト)と見なされ、すべての開いているデータベーストランザクションがコミットされます。その後の挙動は、``HTTP``例外自身によって定められます。``HTTP``例外クラスは、Python標準の例外ではなく、web2pyで定義されています。

### ライブラリ

web2pyのライブラリは、グローバルオブジェクトとしてユーザアプリケーションに公開されます。たとえば、``request``、``response``、``session``、``cache``、クラス(ヘルパー、バリデータ、DALのAPI)、関数(``T``と``redirect``)などがあります。

これらのオブジェクトは、次のコアファイルで定義されています：
``
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
``:code

次の雛形アプリがweb2pyにtar+gzipで圧縮されて同梱されています。
``
welcome.w2p
``:code

このアプリは、インストール時に作成され、アップグレード時に上書きされます。

-------
最初にweb2pyを起動すると、depositとapplicationsという2つの新しいフォルダが作成されます。"welcome"アプリは"welcome.w2p"ファイルに圧縮され、雛形アプリとして利用されます。depositフォルダはアプリケーションのインスール、アンインストールのための一時的な保存場所として使用されます。
-------

web2pyのユニットテストはここに保存されています。
``
gluon/tests/
``:code

さまざまなWebサーバと接続するためのハンドラがあります：
``
cgihandler.py
gaehandler.py
fcgihandler.py
wsgihandler.py
modpythonhandler.py
gluon/contrib/gateways/__init__.py
gluon/contrib/gateways/fcgi.py
``:code

(fcgi.pyは、Allan Saddiによって開発されたものです)

また、2つのサンプルファイルがあります：
``
options_std.py
routes.example.py
``:code

1番目はオプション的な設定ファイルで、``-L``オプションでweb2py.pyに渡されます。2番目はURLマッピングファイルの例です。"routes.py"に名前を変更すると、自動的に読み込まれるようになります。

次のファイルは
``
app.yaml
index.yaml
``:code

Google App Engine上にデプロイするために必要な設定ファイルです。詳しくは、デプロイレシピの章とGoogleのドキュメンテーションのページをご覧ください。

また、多くはサードパーティによって開発された追加的なライブラリがあります：

**feedparser**``feedparser``:citeはMark Pilgrimによって作られた、RSSとAtomのフィードを読み取るためのものです：
``
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
``:code

**markdown2**``markdown2``:citeはTrent Mickによって作られた、wikiマークアップ用のものです：
``
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
``:code

**markmin**のマークアップです：
``
gluon/contrib/markmin.py
``:code

**pysimplesoap**はMariano Reingartによって作成された軽量なSOAPサーバーの実装です。

``
gluon/contrib/pysimplesoap/
``:code

**memcache**``memcache``:cite用のPython APIです。Evan Martinによって作成されました：
``
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
``:code

**gql**は、DALをGoogle App Engine用に移植したものです。
``
gluon/contrib/gql.py
``:code

**memdb**は、DALをmemcache上に移植したものです：
``
gluon/contrib/memdb.py
``:code

**gae_memcache**は、Google App Engine上でmemcacheを使うためのAPIです。
``
gluon/contrib/gae_memcache.py
``:code

**pyrtf**``pyrtf``:citeは、リッチテキストフォーマット(RTF)を生成するためのライブラリです。Simon Cusackによって開発され、Grant Edwardsにより改定されました。
``
gluon/contrib/pyrtf
gluon/contrib/pyrtf/__init__.py
gluon/contrib/pyrtf/Constants.py
gluon/contrib/pyrtf/Elements.py
gluon/contrib/pyrtf/PropertySets.py
gluon/contrib/pyrtf/README
gluon/contrib/pyrtf/Renderer.py
gluon/contrib/pyrtf/Styles.py
``:code

**PyRSS2Gen**``pyrss2gen``:citeはRSSフィードを生成するためのものです。Dalke Scientific Softwareによって開発されました：
``
gluon/contrib/rss2.py
``:code

**simplejson**``simplejson``:citeはJSONオブジェクトをパースし書くための標準ライブラリです。Bob Ippolitoによって作成されました：
``
gluon/contrib/simplejson/__init__.py
gluon/contrib/simplejson/decoder.py
gluon/contrib/simplejson/encoder.py
gluon/contrib/simplejson/jsonfilter.py
gluon/contrib/simplejson/scanner.py
``:code

**AuthorizeNet**``authorizenet``:citeは、Authorize.netネットワークを介してクレジットカードの支払いを受け入れるAPIを提供します
``
gluon/contrib/AuthorizeNet.py
``:code

**PAM**``PAM``:cite用のChris AtLeeによって作られた認証APIです：
``
gluon/contrib/pam.py
``:code

テスト用のダミーデータをデータベースに入力するためのベイズ分類機です：
``
gluon/contrib/populate.py
``:code

web2pyがサービスとして稼働しているとき、windowsのタスクバーでインタラクティブな操作を行うためのファイルです：
``
gluon/contrib/taskbar_widget.py
``:code

オプションで用意されている**login_methods**とlogin_formsは、認証で使用されます：
``
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
``:code

web2pyにはまた、便利なスクリプトが収められているフォルダがあります。
``
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/cleancss.py
scripts/cleanhtml.py
scripts/contentparser.py
scripts/repair.py
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
...
``:code

最初の2つは特に便利で、web2pyの本番環境の完全なインストールとセットアップをスクラッチで行うよう試みます。これらは第12章にて説明されます。ただし、多かれ少なかれ、それら自身で説明されています。

最後に、web2pyはバイナリ配布をビルドするために必要なファイルを含んでいます。
``
Makefile
setup_exe.py
setup_app.py
``:code

これらは**py2exe**と**py2app**ためのそれぞれのセットアップスクリプトです。web2pyのバイナリ配布をビルドするためだけに必要とされます。あなたがそれらを実行することはありません。

要約すると、 web2pyのライブラリは次の機能を提供します：
- URLを関数呼び出しに割り当てます。
- HTTP経由のパラメータの受け渡しを行います。
- それらのパラメータの検証を行います。
- 大抵のセキュリティ問題からアプリケーションを保護します。
- データの永続性(データベース、セッション、キャッシュ、クッキー)を扱います。
- 幾多のサポートされた言語用に文字列の翻訳を行います。
- HTMLをプログラム的に生成します(データベーステーブルからなど)。
- データベース抽象化レイヤ(DAL)を介してSQLを生成します。
- リッチテキストフォーマット(RTF)出力を生成します。
- Comma-Separated Value(CSV)形式の出力をデータベースのテーブルから生成します。
- Really Simple Syndication(RSS)フィードを生成します。
- JavaScript Object Notation (JSON)をAjax用にシリアライズした文字列を生成します。
- wikiマークアップ(Markdown)をHTMLに変換します。
- XML-RPCのWebサービスを公開します。
- 大きいファイルのアップロードとダウンロードをストリーミングして行います。

web2pyアプリケーションにはさらにファイルがあります。特に、jQuery、calendar、EditArea、nicEditなどのサードパーティ製のJavaScriptライブラリが含まれています。作者の情報はファイル自体に記載されています。

### アプリケーション

web2pyで開発されたアプリケーションは、以下のパーツから構成されています：
- **models**は、データベースのテーブルとテーブル間のリレーションのようなデータの表現を記述します。
- **controllers**は、アプリケーションのロジックとワークフローを記述します。
- **views**は、JavaScriptとHTMLを使用してユーザにデータをどのように提示するかを記述します。
- **languages**は、アプリケーションの文字列を様々なサポートされている言語にどのように翻訳するかを記述します。
- **static files**は、処理を必要としません(たとえば画像やCSSスタイルシート等)。
- **ABOUT** and **README**は、その名のとおりの文書です。
- **errors**は、アプリケーションで発生したエラーのレポートを保存します。
- **sessions**は、各ユーザー固有の情報を保存します。
- **databases**は、SQLiteデータベースと、付加的なテーブル情報を保存します。
- **cache**は、キャッシュされたアプリケーションのアイテムを保存します。
- **modules**は、その他の追加Pythonモジュールです。
- **private**ファイルは、コントローラからアクセスされますが、開発者から直接アクセスされません。
- **uploads**ファイルは、モデルからアクセスされますが、開発者から直接アクセスされません(ユーザによりアップロードされたファイルなど)。
- **tests**は、テスト用のスクリプト、ちょっとしたプログラムやモックを格納するためのディレクトリです。

models、views、controllers、languages、static filesは、Webの管理[デザイン]インターフェイスを介してアクセス可能です。ABOUT、README、errorsも、管理インターフェイスを介して対応するメニュー項目を経てアクセスできます。sessions、cache、modules、private filesは、アプリケーションからはアクセスできますが、管理インターフェイスからはできません。

ユーザがファイルシステムに直接アクセスする必要はないですが、すべては明確なディレクトリ構造にきれいに構造化されています。そして、インストールした各web2pyのアプリケーションに対して複製されます。

``about``:inxx ``license``:inxx ``cache``:inxx ``controllers``:inxx ``databases``:inxx ``errors``:inxx ``languages``:inxx ``models``:inxx ``modules``:inxx ``private``:inxx ``session``:inxx ``static``:inxx ``tests``:inxx ``uploads``:inxx ``views``:inxx ``__init__.py``:inxx
``
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
``:code

"__init__.py"は、空のファイルで、Pythonが``modules``ディレクトリ内のモジュールをインポートするために必要となります。

なお、**admin**アプリケーションは、サーバのファイルシステムに置かれたweb2pyアプリケーションのためのWebインターフェイスを簡単に提供します。web2pyアプリケーションは、コマンドラインから作成、開発を行うこともできます。必ずしも、ブラウザの**admin**インターフェイスを使用しなければならないというわけではありません。新規のアプリケーションは、上記のディレクトリ構造を、たとえば、"applications/newapp/"の下に複製して手動で作ることができます(または新規アプリケーションのディレクトリにおいて``welcome.w2p``を単純にuntarで展開しても可能です)。アプリケーションのファイルは、**admin**インターフェイスを使わずに、コマンドラインから作成や編集を行うことも可能です。

### API

models、controllers、viewsは、次のオブジェクトがすでにインポートされている環境で実行されます：

**グローバルオブジェクト：** ``request``:inxx ``response``:inxx ``session``:inxx ``cache``:inxx

``
request, response, session, cache
``:code

**ナビゲーション：** ``redirect``:inxx ``HTTP``:inxx

``
redirect, HTTP
``:code

**国際化対応：** ``T``:inxx ``internationalization``:inxx

``
T
``:code

**ヘルパー：** ``helpers``:inxx

``
XML, URL, BEAUTIFY

A, B, BEAUTIFY, BODY, BR, CENTER, CODE, DIV, EM, EMBED,
FIELDSET, FORM, H1, H2, H3, H4, H5, H6, HEAD, HR, HTML,
I, IFRAME, IMG, INPUT, LABEL, LEGEND, LI, LINK, OL, UL,
MARKMIN, MENU, META, OBJECT, ON, OPTION, P, PRE, SCRIPT,
OPTGROUP, SELECT, SPAN, STYLE, TABLE, TAG, TD, TEXTAREA,
TH, THEAD, TBODY, TFOOT, TITLE, TR, TT, URL, XHTML, 
xmlescape, embed64
``:code

**バリデータ：** ``validators``:inxx

``
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
``:code

**データベース：** ``DAL``:inxx

``
DAL, Field
``:code

下位互換性のために、``SQLDB``=``DAL``と``SQLField=Field``となっています。新しい構文である``DAL``と``Field``を、古い構文の代わって使うことを推奨します。

他のオブジェクトとモジュールは同じライブラリで定義されます。しかし、そこまで頻繁に利用されるわけではないので、自動的にはインポートされません。

web2pyの実行環境におけるコアとなるAPIの構成要素は、後述する、``request``、``response``、``session``、``cache``、``URL``、``HTTP``、``redirect``、``T``です。

**Auth**、**Crud**、**Service**などのいくつかのオブジェクトや関数は、”gluon/tools.py"で定義されています。それらは、必要な時にimportする必要があります：
``
from gluon.tools import Auth, Crud, Service
``:code

### ``request``
``request``:inxx ``Storage``:inxx ``request.cookies``:inxx

``request``オブジェクトはPythonの``dict``クラスを拡張した``gluon.storage.Storage``という普遍的なweb2pyのクラスのインスタンスです。基本的には辞書ですが、アイテムの値は属性としてアクセスすることができます：
``
request.vars
``:code

これは次と同じです：
``
request['vars']
``:code

辞書とは異なり、属性(またはキー)がない場合、例外を発生させず、代わりに、``None``を返します。``request``は以下のアイテム/属性を持ちます。そのうちのいくつかはまた``Storage``クラスのインスタンスです：
- **request.cookies**: HTTPリクエストにより渡されたクッキーを格納する``Cookie.SimpleCookie()``オブジェクトです。クッキーの辞書のように動作します。各クッキーはMorselオブジェクトです。
- **request.env**:コントローラに渡される環境変数を格納する``Storage``オブジェクトです。HTTPリクエストからのHTTPヘッダ変数と標準のWSGIパラメータを含みます。環境変数はすべて小文字に変換され、覚えやすいようにドットはアンダースコアに変換されます。
- **request.application**:リクエストされたアプリケーションの名前です(``request.env.path_info``からパースされる)。
- **request.controller**:リクエストされたコントローラの名前です(``request.env.path_info``からパースされる)。
- **request.function**:リクエストされた関数の名前です(``request.env.path_info``からパースされる)。
- **request.extension**:リクエストアクションの拡張子です。デフォルトは”html”です。もしコントローラの関数が辞書を返し、かつビューが指定されなかった場合、辞書をレンダリングするビューファイルの拡張子を決めるために利用されます(``request.env.path_info``からパースされる)。
- **request.folder**:アプリケーションのディレクトリです。たとえばアプリケーションが"welcome"の場合、``request.folder``には"/path/to/welcome"という絶対パスが設定されます。プログラムにおいて、アクセスするファイルへのパスを構築するには、この変数と``os.path.join``関数を常に使用すべきです。web2pyはたいてい絶対パスを使用していますが、現在の作業フォルダは(何であれ)決して変更しないということが、良いルールです。スレッドセーフなプラクティスではないからです。
- **request.now**:現在のリクエストのタイムスタンプを保存した``datetime.datetime``オブジェクトです。
- **request.args**:コントローラの関数名の後に続く、URLパス成分のリスト。``request.env.path_info.split('/')[3:]``と等しいです。
- **request.vars**:a ``gluon.storage.Storage`` object containing the HTTP GET and HTTP POST query variables.
- **request.get_vars**:HTTP GETとHTTP POSTのクエリ変数を格納する``gluon.storage.Storage``オブジェクトです。
- **request.post_vars**:HTTP GETのクエリ変数のみを格納する``gluon.storage.Storage``オブジェクトです。
- **request.client**:クライアントのIPアドレスです。提示されていれば、``request.env.http_x_forwarded_for``から、そうでない場合は、``request.env.remote_addr``から決定されます。これは有用ですが、``http_x_forwarded_for``は偽装することができるため信頼すべきものではありません。
- **request.body**:HTTPリクエストのボディが含まれている、読み取り専用ファイルストリームです。これは``request.post_vars``を取得するために自動的に解析されます。解析後は、ストリームの位置は戻ります。``request.body.read()``で読むことができます。
- **request.ajax**は、呼ばれる関数がAjaxリクエストを介したものだとTrueになります。
- **request.cid**は、(任意の)Ajaxリクエストを生成したコンポーネントの``id``です。コンポーネントの詳細については第13章を読んでください。
- **request.wsgi**は、アプリケーション内部からサードパーティのWSGIアプリケーションを呼び出せるようにするフックです。

例として、典型的なシステム上での次の呼び出しは：
``
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
``:code

次の表のようになります：
``request``:inxx ``env``:inxx

----------
variable | value
request.application | examples
request.controller | default
request.function | index
request.extension | html
request.view | status
request.folder | applications/examples/
request.args | ['x', 'y', 'z']
request.vars | <Storage {'p': 1, 'q': 2}>
request.get_vars | <Storage {'p': 1, 'q': 2}>
request.post_vars | <Storage {}>
request.cid | None
request.wsgi | hook
request.env.content_length | 0
request.env.content_type | ````
request.env.http_accept | text/xml,text/html;
request.env.http_accept_encoding | gzip, deflate
request.env.http_accept_language | en
request.env.http_cookie | session_id_examples=127.0.0.1.119725
request.env.http_host | 127.0.0.1:8000
request.env.http_max_forwards | 10
request.env.http_referer | http://web2py.com/
request.env.http_user_agent | Mozilla/5.0
request.env.http_via | 1.1 web2py.com
request.env.http_x_forwarded_for | 76.224.34.5
request.env.http_x_forwarded_host | web2py.com
request.env.http_x_forwarded_server | 127.0.0.1
request.env.path_info | /examples/simple_examples/status
request.env.query_string | remote_addr:127.0.0.1
request.env.request_method | GET
request.env.script_name | ````
request.env.server_name | 127.0.0.1
request.env.server_port | 8000
request.env.server_protocol | HTTP/1.1
request.env.web2py_path | /Users/mdipierro/web2py
request.env.we2bpy_version | Version 1.83.1
request.env.web2py_runtime_gae | (optional, defined only if GAE detected)
request.env.wsgi_errors | <open file, mode 'w' at >
request.env.wsgi_input | ````
request.env.wsgi_multiprocess | False
request.env.wsgi_multithread | True
request.env.wsgi_run_once | False
request.env.wsgi_url_scheme | http
request.env.wsgi_version | 10
--------

どのような環境変数が実際に定義されているかは、Webサーバーによって異なります。この例では、組み込みまれたRocket wsgiのサーバーを想定しています。変数のセットはApacheのWebサーバーを使用した場合でも大きな違いはありません。

``request.env.http_*``変数は、HTTPリクエストヘッダから解析されたものです。

``request.env.web2py_*``変数。これらは、Webサーバー環境から解析されたものではありません。web2pyの実行場所やバージョン、あるいはGoogle App Engine上で動いているかどうか(個別の最適化が必要かもしれないため)ということをアプリケーションが知るために、web2pyによって作成されます。

また、``request.env.wsgi_*``変数もあります。これらはWSGIアダプタに固有です。

### ``response``
``response``:inxx
``response.body``:inxx
``response.cookies``:inxx
``response.download``:inxx
``response.files``:inxx
``response.flash``:inxx
``response.headers``:inxx
``response.meta``:inxx
``response.menu``:inxx
``response.postprocessing``:inxx
``response.render``:inxx
``response.status``:inxx
``response.stream``:inxx
``response.subtitle``:inxx
``response.title``:inxx
``response.view``:inxx
``response.js``:inxx
``response.write``:inxx

``response``は、もう1つの``Storage``インスタンスです。以下のものを格納しています：

**response.body**: ``StringIO``オブジェクトです。web2pyはこれに対して出力ページの本体を書き込みます。！！この変数は決して変更しないでください！！

**response.cookies**: **request.cookies**と似ていますが、後者はクライアントからサーバーに送られるクッキーを格納するのに対し、前者はサーバーからクライアントに送られるクッキーを格納します。セッションクッキーは自動的に処理されます。

**response.download(request, db)**: アップロードされたファイルのダウンロードを可能にするコントローラ関数を実装する際に用いるメソッドです。

**response.files**: ページで必要なJSとCSSの一覧です。これらは、標準の"layout.html"のヘッダーにて、自動的にリンクが追加されます。新しいCSSやJSファイルを含めるには、このリストに追加するだけです。重複処理は行われます。順序は意味を持ちます。

**response.flash**: ビューに組み込まれるオプションパラメータです。通常は何か起こったことをユーザに通知するために使用されます。

**response.headers**: HTTPレスポンスヘッダのための``dict``です。

**response.menu**: ビューに組み込まれるオプションパラメータです。通常はビューにナビゲーションメニューツリーを渡すために使用されます。MENUヘルパーでレンダリングすることができます。

**response.meta**: ``response.meta.author``、かつ/または、``response.meta.description``、``response.meta.keywords``のような、省略可能なメタ情報を格納する(辞書的な)ストレージオブジェクトです。メタ変数の内容は、自動的に正しいMETAタグに入れられます。これは、デフォルトでは、"views/layout.html"によって組み込まれる"web2py_ajax.html"内のコードによって行われます。

**response.postprocessing**: これは関数のリストです。デフォルトは空です。この中の関数はアクションの出力時に、ビューによって出力がレンダリングされる前に、レスポンスオブジェクトをフィルタするために用いられます。これは、他のテンプレート言語のサポートを実装するために利用できます。

**response.render(view, vars)**: コントローラ内部のビューを明示的に呼び出すためにに使用するメソッドです。``view``はオプションパラメータで、ビューファイルの名前を指定します。``vars``は、ビューに渡される名前付けされた値の辞書です。

**response.session_file**: セッションを格納するファイルストリームです。

**response.session_file_name**: セッションが保存されるファイルの名前です。

**response.session_id**: 現在のセッションIDです。IDは自動的に決定されます。この変数は決して変更しないでください。

**response.session_id_name**: このアプリケーションのセッションクッキーの名前です。この変数は決して変更しないでください。

**response.status**: レスポンスに渡されるHTTPステータスコードの数字です。デフォルトは200(OK)です。

**response.stream(file, chunk_size)**: コントローラがこれを返す時、web2pyはファイルの内容を``chunk_size``のブロックごとにクライアントに戻します。

**response.subtitle**:  ビューに組み込まれるオプションパラメータです。ページのサブタイトルを格納します。

**response.title**: ビューに組み込まれるオプションパラメータです。ページのタイトルを格納し、ヘッダのHTMLタイトルTAGによってレンダリングされます。

**response._vars**: この変数は、アクションではなく、ビューにおいてのみアクセス可能です。アクションがビューに対して返す値を格納します。

**response.view**:  ビューのテンプレートの名前です。このテンプレートはページを必ずレンダリングします。デフォルトでは次のように設定されています：
``
"%s/%s.%s" % (request.controller, request.function, request.extension)
``:code

上記のファイルがない場合は、次のようになります。
``
"generic.%s" % (request.extension)
``:code

この変数の値を変えると、特定のアクションに関連付けられたビューファイルが変更されます。

**response.xmlrpc(request, methods)**: コントローラがこれを返す時、この関数はXML-RPC``xmlrpc``:citeを介して公開されます。この関数は、第9章で説明するより良い方法が存在するため、現在は推奨されていません。

**response.write(text)**: 出力ページのボディにテキストを書くメソッドです。

**response.js**は、Javascriptのコードを格納することができます。レスポンスが第13章で説明するweb2pyコンポーネントによって受け取られた場合に限り、このコードが実行されます。

**response**は``gluon.storage.Storage``オブジェクトです。ビューに渡す他の属性も格納することができます。技術的な制約はありませんが、全体的なレイアウト("layout.html")にあるすべてのページによってレンダリングさ れる変数だけを保存することを推奨します。

いずれにせよ、ここに記載した変数を利用し続けることを強くお勧めします：
``
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
``:code

これにより、web2pyに同梱された標準の"layout.html"ファイルを、同じ変数セットを利用する別のレイアウトファイルに置き換えることが容易になります。

古いバージョンのweb2pyは``response.meta.author``の代わりに``response.author``を用いていました。他のmeta属性も同様です。

### ``session``
``session``:inxx ``session.connect``:inxx ``session.forget``:inxx ``session.secure``:inxx
``session``は、もう1つの``Storage``インスタンスです。``session``に対して次のように格納したものは何でも：
``
session.myvariable = "hello"
``:code

後で読み出すことができます。
``
a = session.myvariable
``:code

同じユーザである限り、同じセッションの元でコードが実行されます(ユーザがセッションクッキーを削除せず、セッションが無効になってない限りです)。``session``は``Storage``オブジェクトであるので、存在しない属性/キーの組み合わせでアクセスしても例外は発生しません。代わりに``None``が返されます。

セッションオブジェクトには、2つの重要なメソッドがあります。1つは**forget**です：
``
session.forget()
``:code

これは、web2pyにセッションを保存しないよう指示します。アクションが頻繁に呼ばれ、かつ、ユーザの活動を追跡する必要がないコントローラにおいて使用されます。

もう1つのメソッドは、**connect**です：
``
session.connect(request, response, db, masterapp=None)
``:code

ここで、``db``は(DALによって返される)開いているデータベース接続の名前です。これは、web2pyに、ファイルシステムではなくデータベースにセッションを保存するよう指示します。 web2pyは次のようにテーブルを作成し：
``
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
``:code

cPickledされたセッションを``session_data``フィールドに保存します。

``masterapp=None``というオプションは、デフォルトでは、動作中のアプリケーションの、つまり、``request.application``の名前のアプリケーションに対する既存のセッションを取得するようにします。

複数のアプリケーションでセッションを共有したい場合は、``masterapp``にマスタとなるアプリケーションの名前を設定します。

アプリケーションの状態は、``request``、``session``、``response``のシステム変数を表示することで、いつでもチェックすることができます。その1つの方法は次のような専用のアクションを用意することです：
``
def status():
    return dict(request=request, session=session, response=response)
``:code

### ``cache``
``cache``:inxx ``cache.ram``:inxx ``cache.disk``:inxx
``cache``もまた、web2pyの実行環境で用意されているグローバルオブジェクトです。これは次の2つの属性を持っています：
- **cache.ram**: メインメモリ上のアプリケーションキャッシュです。
- **cache.disk**: ディスク上のアプリケーションキャッシュです。
``cache``は呼び出し可能であり、アクションやビューをキャッシュするためのデコレータとして使うことができます。

次の例では、``time.ctime()``関数をRAM上でキャッシュしています：
``
def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``の出力結果は、RAM上で5秒間キャッシュされます。文字列``'time'``はキャッシュのキーとして使用されます。

次の例は、``time.ctime()``関数をディスク上でキャッシュします：
``
def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``の出力結果は、(shelveモジュールを用いて)ディスク上で5秒間キャッシュされます

次の例は、``time.ctime()``関数をRAM上とディスク上の両方でキャッシュします：
``
def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``の出力結果は、5秒間、(shelveモジュールを用いて)ディスク上にキャッシュされ、続いて、RAM上でキャッシュされます。web2pyは最初はRAMから、見つからない場合はディスクから探します。RAMとディスクのいずれにも存在しない場合、``lambda: time.ctime()``が実行され、キャッシュが更新されます。この手法はマルチプロセス環境で有用です。2つのtimeは同じである必要はありません。

次の例は、コントローラの関数の結果をRAM上にキャッシュします(ビューはキャッシュしません)。

``cache controller``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``cache_controller_in_ram``によって返される辞書はRAM上に5秒間キャッシュされます。注意として、データベースの選択結果は、最初にシリアル化がされなければキャッシュすることができません。より良い方法は、``select``メソッドの``cache``引数を使って、データベースを直接キャッシュすることです。

次の例は、コントローラの関数の結果をディスクにキャッシュします(ビューはキャッシュしません)。
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))
``:code

``cache_controller_in_ram``によって返される辞書はディスク上に5秒間キャッシュされます。なお、pickle化できないオブジェクトを含む辞書はキャッシュできないことに留意してください。

ビューをキャッシュすることも可能です。コントローラ関数でビューをレンダリングすることによって可能です。コントローラが文字列を返すことになるからです。これは、``response.render(d)``を返すことで実行されます。ここでdはビューに渡すつもりであった辞書です：

``time_expire``は``0``に設定することができ、これによってキャッシュを強制的にリフレッシュします。``None``を設定すると内容の期限が切れるのを防ぎます。

次のようにすると複数のキャッシュ変数を消すことができます：
``cache clear``:inxx

``
cache.ram.clear(regex='...')
``:code

ここで、 ``regex``はキャッシュから消したいキーにマッチする正規表現です。

次の例は、(レンダリングされたビューを含む)コントローラの関数の出力をRAM上にキャッシュします：

``cache view``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)
``:code
``response.render(d)``は、レンダリングされるビューを、文字列で返します。そしてそれは5秒間キャッシュされます。これは最良の、そして、最速のキャッシュ方法です。

また、memcacheのような他のキャッシュメカニズムを定義することも可能です。Memcacheは``gluon.contrib.memcache``を介して利用可能で、第11章にて詳しく説明されています。

### ``URL``
``URL``:inxx
``URL``関数は、web2pyにおいて最も重要な関数の1つです。これは、アクションと静的ファイルのための内部URLのパスを生成します。

たとえば、これは:

``
URL('f')
``:code

次のようにマッピングされます

``
/[application]/[controller]/f
``:code

ただし、``URL``関数の出力は現在のアプリケーションの名前や、呼んだコントローラ、他のパラメータに依存します。URLのマッピングや、逆向きのURLのマッピングもサポートしています。URLのマッピングによって、外部URLの形式を再定義することができます。``URL``関数をすべての内部URLの生成に用いる場合、URLマッピングに追記や変更を加えることで、web2pyアプリケーション内のリンク切れが防止されます。

``URL``関数に追加のパラメータ、すなわち、URLのさらなるパス(args)やURLのクエリ変数(vars)を渡すことができます：

``
URL('f', args=['x', 'y'], vars=dict(z='t'))
``:code

これは、次のようにマッピングされます

``
/[application]/[controller]/f/x/y?z=t
``:code

``args``属性は、web2pyによって自動的に解析され、復号化され、最後に、``request.args``に格納されます。同様に、 ``vars``は、解析され、復号化され、そして、``request.vars``に格納されます。``args``と``vars``は、web2pyがクライアントのブラウザと情報の交換をするための基本的な仕組みを提供します。

argsが1つの要素しか含まない場合、リストにしてそれを渡す必要はありません。

``URL``関数は、他のコントローラや他のアプリケーションのURLを生成するためにも用いることができます：

``
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
``:code

これは、次のようにマッピングされます

``
/a/c/f/x/y?z=t
``

アプリケーション、コントローラ、関数を名前付き引数で指定することも可能です：

``
URL(a='a', c='c', f='f')
``:code

アプリケーションの名前aがない場合、現在のアプリが想定されます。

``
URL('c', 'f')
``:code

コントローラの名前がない場合は、現在のものが想定されます。

``
URL('f')
``:code

コントローラの関数の名前を渡す代わりに、関数自身を渡すことも可能です。

``
URL(f)
``:code

上で説明した理由により、アプリケーションで静的ファイルのURLを生成するには、``URL``関数を常に用いるべきです。静的ファイルはアプリケーションの``static``サブフォルダに保存されています(管理インターフェースを用いてアップロードすることができる場所です)。web2pyは仮想的な'static'コントローラを提供し、それによって``static``サブフォルダからファイルが取り出され、そのcontent-typeが決められ、クライアントにファイルがストリームされます。次の例では、"image.png"という静的ファイルに対するURLを生成しています：

``
URL('static', 'image.png')
``:code

これは、次のようにマッピングされます

``
/[application]/static/image.png
``:code

``args``と``vars``の引数はエンコード/エスケープする必要はありません。それは自動的に行われるからです。

デフォルトでは、現在のリクエストに対応する拡張子(request.extension)は、request.extensionがデフォルトのhtmlでない限り、関数に追加されます。これを書き換えるには、``URL(f='name.ext')``のように関数名の一部として拡張子を明示的に含めるか、次のように拡張子の引数によって行います：
``
URL(..., extension='css')
``:code

現在の拡張子を明示的に抑制するには次のようにします：
``
URL(..., extension=False)
``:code

### ``HTTP``と``redirect``
``HTTP``:inxx ``redirect``:inxx

web2pyは``HTTP``という新しい例外を1つだけ定義しています。この例外は、モデル、コントローラ、ビューのどこにおいても、次のコマンドで発生させることができます：

``
raise HTTP(400, "my message")
``:code

これによって、フロー制御はユーザのコードからジャンプしてweb2pyに戻り、次のようなHTTPレスポンスを返します：
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message
``:code

``HTTP``の最初の引数はHTTPステータスコードです。2番目の引数はレスポンスのボディとして返される文字列です。その他のオプション的な名前付き引数は、HTTPレスポンスヘッダを作成するために使用されます。たとえば:
For example:
``
raise HTTP(400, 'my message', test='hello')
``:code

これは以下を生成します：
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message
``:code

もし開いているデータベーストランザクションをコミットしたくなければ、例外が発生する前にロールバックしてください。

``HTTP``以外のいかなる例外では、web2pyによって、すべての開いているデータベーストランザクションがロールバックされ、エラーのトレースバックがログに保存され、訪問者に対するチケットが発行され、標準的なエラーページが返されます。

これは、``HTTP``だけがページ間のフロー制御のため使用することができることを意味します。その他の例外は、アプリケーションによって捕捉されなければならず、そうしないとweb2pyによってチケットが切られます。

次のコマンドは：
``
redirect('http://www.web2py.com')
``:code

単に以下のショートカットです：
``
raise HTTP(303,
           'You are being redirected <a href="%s">here</a>' % location,
           Location='http://www.web2py.com')
``:code

この``HTTP``を初期化するメソッドの名前付き引数は、HTTPヘッダのディレクティブへと変換されます。この場合はリダイレクト先の場所になります。``redirect``は、リダイレクトのためのHTTPステータスコード(デフォルトでは303)をオプション的な2番目の引数にて受け取ります。この数字を307に変更すると一時的なリダイレクトになり、301に変更すると永久的なリダイレクトになります。

ユーザリダイレクトの最も一般的な方法は、次のように同じアプリ内の他のページにリダイレクトし、(オプション的に)パラメータを渡すことです：

``
redirect(URL('index',args=(1,2,3),vars=dict(a='b')))
``:code

### ``T``と国際化
``T``:inxx ``internationalization``:inxx

``T``オブジェクトは言語の翻訳機です。これは、web2pyのクラスである``gluon.language.translator``の単一のグローバルインスタンスから構成されています。すべての文字列定数は(そして文字列定数のみ)次の例のように``T``によってマークされるべきです：
``
a = T("hello world")
``:code

``T``によってマークされた文字列は、言語の翻訳が必要なものとしてweb2pyによって特定され、(モデル、コントローラ、ビューの)コードが実行されたときに翻訳されます。翻訳する文字列が定数でなく変数の場合は、後で翻訳するために実行時(GAEを除く)に翻訳ファイルにその文字列が加えられます。

``T``オブジェクトは補完される変数を次の例のように含むことができます：
``
a = T("hello %(name)s", dict(name="Massimo"))
``:code

最初の文字列はリクエストされた言語のファイルに応じて翻訳され、``name``変数が言語と独立に置換されます。

翻訳文字列を連結するのは良いアイデアではありません。そのため、web2pyは次のようにすることを許可していません：
``
T("blah ") + name + T(" blah")   # invalid!
``:code

しかし、次のものは許可しています：
``
T("blah %(name)s blah", dict(name='Tim'))
``:code

次のような代替構文も可能です
``
T("blah %(name)s blah") % dict(name='Tim')
``:code

どちらの場合でも、翻訳は、"%(name)s"スロットの中で変数の名前が置換される前に発生します。次のような代替案は使うべきではありません：
``
T("blah %(name)s blah" % dict(name='Tim'))
``:code

なぜなら、翻訳が置換後に発生するからです。

リクエストされた言語は、HTTPヘッダにある"Accept-Language"フィールドによって決められます。しかし、この選択は、次のように特定のファイルを要求することにより、プログラム上で上書きすることができます：
``
T.force('it-it')
``:code

これは"languages/it-it.py"の言語ファイルを読み取ります。言語ファイルは、管理インターフェースを介して作成、編集することができます。

通常、文字列の変換は、ビューがレンダリングされるときに遅延的に評価されます。したがって、翻訳オブジェクトの``force``メソッドはビュー内で呼び出してはいけません。

遅延評価は次のようにして無効化することが可能です
``
T.lazy = False
``:code

これにより、文字列は、現在のアクセプト、または、強制された言語に基づいて、T演算子によって直ちに翻訳されます。

一般的な問題は次のとおりです。元のアプリケーションが英語で書かれいたとします。翻訳ファイル(たとえばイタリア語、"it-it.py")があり、かつ、HTTPクライアントが英語(en)とイタリア語(it-it)をこの順序で受け入れることを宣言していると想定してください。以下のような望まない状況が発生します：web2pyはデフォルトは英語で書かれていることは知りません。したがって、イタリア語の翻訳ファイルしか見つからないので、すべてをイタリア語(it-it)に翻訳するようにします。もし"it-it.py"ファイルが見つからなかったとすれば、デフォルトの言語の文字列(英語)が使用されたはずです。

この問題には2つの解決方法があります。1つは、英語の翻訳ファイルを作成することですが、それは冗長で不要です。より良い方法は、web2pyにどの言語がデフォルトの言語の文字列を使用するかを知らせることです。これは次のようにして行うことができます：
``
T.set_current_language('en', 'en-en')
``:code

これは、``T.current_languages``に、翻訳が必要でない言語のリストを保存し、言語ファイルのリロードを実施します。

なお、"it"と"it-it"はweb2pyのビューの観点からすると違う言語になります。それらの両方をサポートするためには、常に小文字の名前の、2つの翻訳ファイルが必要となります。他の言語についても同様です。

現在受け入れ可能な言語は次の場所に格納されています
``
T.accepted_language
``:code

T(...)は、単に文字列を変換するだけでなく、変数を翻訳できることに留意してください：
``
>>> a="test"
>>> print T(a)
``:code

この場合、翻訳される単語"test"は、見つからずまた、ファイルシステムが書き込み可能であれば、言語ファイルにある翻訳対象単語リストに追加されます。

### ''クッキー''
``cookies``:inxx

web2pyはPythonのクッキー・モジュールを、クッキーを処理するために使用します。

ブラウザからのクッキーは``request.cookies``にあり、サーバから送られるクッキーは``response.cookies``にあります。

クッキーは次のように設定することができます：
``
response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
``:code

2行目は、ブラウザにクッキーを24時間保持するように伝えます。3行目は、現在のドメインの任意のアプリケーション(URLパス)にクッキーを返送するようにブラウザに指示します。

クッキーは、次のように保護にすることができます：
``
response.cookies['mycookie']['secure'] = True
``:code

保護されたクッキーは、HTTPではなくHTTPS経由でしか返送されません。

クッキーは次のようにして取り出すことができます：
``
if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value
``:code

セッションが無効になってない限り、web2pyの内部では、次のようにクッキーを設定し、セッションを扱うために使用します：
``
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
``:code

### **init** アプリケーション 
``init``:inxx

web2pyをデプロイするとき、デフォルトアプリケーションを設定したい場合があります。すなわち、次のようにURLのパスが空のときに起動するアプリケーションのことです：
``
http://127.0.0.1:8000
``:code

デフォルトでは、空のパスに出くわしたら、web2pyは**init**という名のアプリケーションを参照します。もし、initというアプリケーションがなかったら、**welcome**という名のアプリケーションを参照します。

``default_application``:inxx
デフォルトのアプリケーションの名前は、routes.pyの``default_application``を設定することで、**init**から別の名前に変更することができます。
``
default_application = "myapp"
``:code

注： ``default_application``はweb2pyのバージョン1.83において最初に登場しました。

ここでは、デフォルトアプリケーションを設定する方法は4通り（訳注：原文では3通りと記載）あります：
- あなたのデフォルトアプリケーションをinitと名付けます。
- routes.pyにおいて``default_application``をあなたのアプリケーションの名前に設定します。
- "applications/init"から、あなたのアプリケーションのフォルダへのシンボリックリンクを作成します。
- 次節で説明するURLリライトを使用してください

### URLリライト
``url rewrite``:inxx
``routes_in``:inxx
``routes_out``:inxx

web2pyでは、コントローラのアクションを呼び出す前に、入力されるリクエストのURLパスを書き換えることができます(URLマッピング)。逆に、``URL``関数によって生成されたURLパスも書き換えることができます(リバースURLマッピング)。これを行う理由の1つは、古い仕様のURLを扱うためです。もう1つはパスを単純化し、短くするためです。

この機能を使用するには、"routes.py"という新規ファイルを"web2py"フォルダに作成して、2つのタプル``routes_in``と``routes_out``という2つのリスト(またはタプル)を定義します。各タプルは2つの要素を格納します：置換されるパターンとそこに置換する文字列です。たとえば:

``
routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)
``:code

これらのルーティングによって次のURLは：
``
http://127.0.0.1:8000/testme
``:code

以下のものにマッピングされます：
``
http://127.0.0.1:8000/examples/default/index
``:code

訪問者にとって、すべてのページのURLは``/testme``のように提示されます。

パータンはPythonの正規表現と同じ構文を持っています。たとえば：
``
  ('.*\.php', '/init/default/index'),
``:code

これは、".php"で終わるすべてのURLがインデックスページにマッピングされます。

1つのアプリケーションしか公開するつもりがない場合、アプリケーションのプレフィックスをURLから取り除きたい場合があります。これは次のようにして実現できます：
``
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
``:code

上記の正規表現と混ぜることができるもう1つの別の構文があります。これは、``(?P<name>\w+)``や``\g<name>``の代わりに``$name``を用います。例：
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
``:code

これは、"/example"アプリケーションのプレフィックスをすべてのURLにおいて取り除きます。


``$name``表記を使用して、``routes_in``から``routes_out``へ自動的にマッピングすることが可能になります。ただしこの場合、正規表現を使用することはできません。たとえば次のようになります：
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
``:code

ここで複数のルーティングがある場合、最初にマッチしたURLが実行されます。もしマッチするパタンがない場合、パスはそのままになります。

``$anything``を用いると、行の最後までのすべてにマッチさせることができます。

ここでは、faviconとrobotsリクエストを処理するための最小限の"routes.py"を示します：

``favicon``:inxx ``robots``:inxx
``
routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()
``:code

さらに、複雑な例を示します。"myapp"という単一のアプリを、不必要なプレフィックスなしに公開しますが、同時に、**admin**と**appadmin**とstaticも公開するという例です。

``
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
``:code

ルーティングの一般的な構文は、これまで見てきた簡単な例よりも複雑です：ここではより一般的で代表的な例を示します：
``
routes_in = (
 ('140\.191\.\d+\.\d+:https://www.web2py.com:POST /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
``:code

これは、``https``の``POST``リクエストを、次の正規表現にマッチしたリモートIPから、``www.web2py.com``というホストにマッピングします。
``
140\.191\.\d+\.\d+
``:code

そして、次の正規表現にマッチしたページを
``
/(?P<any>.*)\.php!
``:code

次のものへとリクエストします。
``
/test/default/index?vars=\g<any>
``:code

ここで、 ``\g<any>``は、マッチした正規表現によって置換されます。

全般的な構文は以下のとおりです：
``
[remote address]:[protocol]://[host]:[method] [path]
``:code

表現全体は正規表現としてマッチするので、"."は常にエスケープされ、マッチした部分表現はすべて、Pythonの正規表現の構文に従って``(?P<...>...)``を用いて捉えることができます。

これにより、クライアントのIPアドレスやドメインに基づいて、また、リクエストのタイプやメソッド、パスに基づいて、リクエストを再ルーティングすることが可能になります。また、異なるバーチャルホストを異なるアプリケーションにマッピングすることも可能です。マッチした部分表現はターゲットのURLを構築するために用いることができ、結果的に、GET変数に渡すことができます。

Apacheやlighttpdなどのすべての主要なWebサーバーは、URLをリライトする機能を持っています。本番環境では、それらは``routes.py``に代わる選択肢になります。いずれにせよ、アプリの内部URLをハードコードせず、URL関数でそれらを生成することを強く推奨します。これにより、必要であればルーツを変更することで、あなたのアプリケーションはよりポータブルなものになります。

#### アプリケーション固有のURLリライト
``routes_app``:inxx
パターンベースのシステムを使用したとき、アプリケーションは独自のルーティングを、アプリケーションの基底フォルダに置かれたアプリケーション固有のroutes.pyにて、設定することができます。これは``routes_app``を、入力URLから選択するアプリケーションの名前を決める基底のroutes.pyにて設定することで可能になります。このとき、アプリケーション固有のroutes.pyが基底のroutes.pyの代わりに使用されます。

``routes_app``のフォーマットは``routes_in``と全く同じです。ただし置換パターンが単純にアプリケーションの名前になります。``routes_app``を入力URLに適用してアプリケーション名にならない場合、または、アプリケーション固有のroutes.pyが見つからない場合、基底のroutes.pyがこれまで通り使用されます。

注： ``routes_app``はweb2pyのバージョン1.83で初めて登場しました。

### デフォルトのアプリケーション、コントローラ、関数
``default_application``:inxx
``default_controller``:inxx
``default_function``:inxx

デフォルトのアプリケーション、コントローラ、関数は、routes.pyで適切な値を設定することで、**init**、**default**、**index**から違う名前にそれぞれ変更することができます：
``
default_application = "myapp"
default_controller = "admin"
default_function = "start"
``:code

注：これらの項目は、web2pyのバージョン1.83で初めて登場しました。

### エラーのルーティング
``routes_on_error``:inxx

"routes.py"を用いて、サーバにエラーが起こったとき、訪問者を特定のアクションにリダイレクトさせることも可能です。このマッピングを、各アプリケーション、各エラーコード、各アプリケーションのエラーコード、に対してグローバルに指定することができます。以下はその例です:
``
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]
``:code

各タプルに対して、最初の文字列は"[appname]/[error code]"にマッチします。一致した場合、ユーザは、マッチしたタプルの2番目の文字列にあるURLにリダイレクトされます。チケットが発行された場合、チケットは新規URLに対して、チケットとして呼ばれるGET変数として渡されます。

マッチしないエラーはデフォルトのエラーページが表示されます。このデフォルトのエラーページもカスタマイズすることができます：
``
error_message = '<html><body><h1>Invalid request</h1></body></html>'
error_message_ticket = '''<html><body><h1>Internal error</h1>
     Ticket issued: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
``:code

最初の変数は、無効なアプリケーションがリクエストされていたときのエラーメッセージです。2番目の変数は、チケットが発行されたときのエラーメッセージを格納します。

### ''クーロン''
``cron``:inxx

web2pyのクーロンは、アプリケーションが予め設定された時刻に、プラットフォームに依存しない形で、タスクを実行することができるように提供されたものです。

各アプリケーションでは、クーロンの機能は"app/cron/crontab"にあるクーロンタブファイルによって定義されます。その構文は参照``cron``:citeに従っています(web2py独自の拡張がいくつかあります)。

このことは、すべてのアプリケーショが個別にクーロンの設定を持つことができ、クーロンの設定がホストOSに左右されることなくweb2pyから変更できることを意味します。

次の例を見てください:
``
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py
``:code

この例の最後の2行は、web2pyの追加機能を提供するために通常のクーロン構文を拡張したものを利用しています。

web2pyのクーロンはweb2pyアプリケーション固有の事情をサポートするいくつかの拡張構文を持っています。

もしスクリプト/関数の名前がアスタリスク(*)で始まり、".py"で終わる場合、それはweb2pyの環境で実行されます。これは、すべてのコントローラとモデルを自由に使えることを意味します。2つのアスタリスク(**)を使用した場合、モデルは実行されません。これは、オーバーヘッドが少なく、潜在的なロックの問題を回避する際に、推奨される呼び出し方法です。

ただし、web2py環境で実行されるスクリプト/関数は、手動のdb.commit()が関数の最後に必要となります。そうしないとトランザクションが戻されます。

web2pyは(クーロンが動作する)シェルモードではチケットや意味のあるトレースバックを生成しません。web2pyコードがエラーなしで動作することを、クーロンタスクとしてセットする前に確認してください。

さらに、どのようにモデルを使用しているかに注意してください。タスクの実行は別プロセスで行われますが、データベースのロックは考慮する必要があります。データベースをブロックするクーロンタスクに対して待機するページを避けるためです。クーロンタスクでデータベースを使わない場合は、** 構文を使用してください。

また、コントローラの関数を呼び出すことができます。パスを指定する必要はありません。コントローラと関数は、呼び出し側のアプリケーションのものです。上に列挙した注意事項に特に注意を払ってください。たとえば：
``
*/30  *  *  *  *  root *mycontroller/myfunction
``:code

このクーロンタブの最初のフィールドで@rebootと明記すると、所定のタスクはweb2py起動時に一度だけ実行されます。この特徴を利用して、web2py起動時にアプリケーションのデータを、事前にキャッシュしたり、検証したり、初期化したりすることができます。なお、クーロンタスクはアプリケーションに並行して実行されます。したがって、もしアプリケーションがクーロンタスクが終わるまでリクエストを受け取る準備ができない場合、タスクが反映されたかチェックするような実装をするべきです。例は次の通りです：
``
@reboot  *  *  *  *  root *mycontroller/myfunction
``:code

どのようにweb2pyを起動しているかに応じて、4つの動作モードがweb2pyのクーロンに対してあります。
- ソフトクーロン：すべての実行モードで利用可能
- ハードクーロン：組み込みのサーバを使用している場合に利用可能(直接もしくはApacheのmod_proxyを介して)
- 外部クーロン：システム自身のクーロンサービスにアクセス出来る場合に利用可能
- クーロンなし

組み込みのサーバを利用している場合、デフォルトはハードクーロンです。他のすべての場合は、デフォルトでソフトクーロンです。

ソフトクーロンはCGI、FASTCGI、WSGIを使用している場合、デフォルトになります。あなたのタスクは、クーロンタブで指定した時刻の後にくるweb2pyへの最初の呼び出し(ページロード)で実行されます(ただし、ユーザーに遅延を発生させないためページの処理が終わった後に行われます)。明らかに、いつタスクが実行されるのかの正確な時刻は、サイトが受け取るトラフィックに依存し、不確実性があります。また、クーロンタスクは、Webサーバーがページ読み込みのタイムアウトを設定している場合、中断されるおそれがあります。これらの制限が許容できない場合は、"外部クーロン"を参照してください。ソフトクーロンは合理的な最後の手段ですが、あなたのWebサーバーが他のクーロン手法が利用出来る場合には、ソフトクーロンよりそちらを利用したほうが良いです。

ハードクーロンは、(直接またはApacheのmod_proxyを介して)組み込みのWebサーバーを使用している場合、デフォルトになります。ハードクーロンは並列スレッドによって実行されるので、ソフトクーロンと異なり、実行時間や実行する正確な時刻に関して制約はありません。

外部クーロンは、どの場合でもデフォルトではありませんが、システムクーロンの設備にアクセスできる必要があります。これは並列プロセスで動作するため、ソフトクーロンで適用されるような制限はありません。これはWSGIやFastCGIの下でクーロンを利用する場合に推奨される方法です。

次のサンプル行は、システムクーロン(通常は /etc/crontab)に挿入されるものです：
``
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -C -D 1 >> /tmp/cron.output 2>&1
``:code

外部クーロンで動すならば、-Nコマンドラインパラメータをweb2pyの起動スクリプトまたは設定に追加していることを確認してください。複数のタイプのクーロンの衝突を回避するためです。 

特定のプロセスでどんなクーロン機能も必要ない場合は、-Nコマンドラインパラメータを用いてそれを無効にすることができます。ただしこれは、いくつかのメンテナンスタスク(自動的なセッションディレクトリのクリーンなど)も無効にするかもしれないことに注意してください。この関数の最も一般的な用途は以下の通りです：
- すでにシステムから起動される外部クーロンを開始している場合(WSGIの設定で最も一般的) 
- アプリケーションをデバッグする際、アクションや出力をクーロンに干渉されたくない場合

### バックグラウンド処理とタスクキュー

クーロンは一定の時間間隔で実行するタスクには便利ですが、バックグラウンドタスクを実行するための解決策として常に最良というわけではありません。このため、web2pyはどのpythonプログラムもコントローラのように実行する機能を提供しています：
``
python web2py.py -S app -M -N -R applications/app/private/myscript.py -A a b c
``:code

ここで、``-S app``は"myscript.py"を"app"として実行することをweb2pyに知らせます。``-M``はモデルを実行することを知らせ、``-N``はクーロンを 動作させないことを知らせます。``-A a b c``はオプション的なコマンドラインの引数``sys.args=['a','b','c']``を"myscript.py"に渡します。

典型的なテスト事例は、キューを処理することです。

次のようなモデルを考えます
``
db.define_table('queue',
    Field('status'),
    Field('email'),
    Field('subject'),
    Field('message'))
``:code

また、次のように送られるメッセージをキューに入れるアプリケーションを考えます
``
db.queue.insert(status='pending',
                email='you@example.com',
                subject='test',
                message='test')
``:code

メールを送るバックグラウンド処理のスクリプトは次のようにします
``
## in file myscript.py
import time
while True:
    rows = db(db.queue.status=='pending').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='sent')
        else:
            row.update_record(status='failed')
        db.commit()
    time.sleep(60) # check every minute
``:code

なお、``mail``オブジェクトは雛形となるアプリの``db.py``ファイルにて定義されたものですが、``-M``オプションがあるため、ここで利用できることに注意してください。mailは``db.py``にてきちんと動作するように設定する必要があります。ただしまた、どのような変更でもすぐにコミットすることは重要です。他の並行して走るプロセスに対してデータベースをロックしないようにするためです。

このタイプのバックグラウンド処理は、クーロンで実行するべきではありません(@rebootのクーロン以外は)。なぜなら、同時に実行されるインスタンスが1つしかないことを保証する必要があるからです。クーロンでは、プロセスがクーロンのイテレーション1を開始し、クーロンのイテレーション2によって終了できない可能性があり、その場合、クーロンはさらにそれを開始し、開始し、というようになって、メールサーバを妨害します。

### サードパーティ製のモジュール
``import``:inxx ``local_import``:inxx

web2pyはPythonで書かれているので、サードーパーティ製のものも含め任意のPythonモジュールをインポートして使うことができます。それらを見つけられるようにするだけです。

任意のPythonアプリケーションと同様に、モジュールは公式のPython"site-packages"ディレクトリにてインストールすることができ、コードのどの場所からでもインポートすることができます。

"site-packages"にあるモジュールは、その名が示すように、サイトレベルのパッケージです。site-packagesを必要とするアプリケーションは、それらのモジュールが個別にインストールできないのであれば、ポータブルではありません。"site-pacakages"にモジュールを持つ利点は、複数のアプリケーションがそれを共有できることです。たとえば、"matplotlib"というグラフ描画用のパッケージを考えましょう。これはPEAKの``easy_install``コマンドを使用してシェルからインストールすることができます。：
``
easy_install py-matplotlib
``:code

そうすると、すべてのモデル/コントローラ/ビューにおいてそれをインポートすることができます：
``
import matplotlib
``:code

web2pyのソース配布とWindows版のバイナリ配布は1つのsite-packagesをそのトップレベルのフォルダに持っています。Mac版のバイナリ配布は、そのフォルダ内にsite-packagesがあります：

``web2py.app/Contents/Resources/site-packages``:code

site-packagesを使用する際の問題は、1つのモジュールの複数のバージョンを同時に使用することが難しいことです。つまり、2つのアプリケーションが1つのファイルの異なるバージョンを使用する場合があることです。この場合、sys.pathはどちらのアプリケーションにも影響するため変更することができません。

web2pyは"modules"フォルダからインポートするとき必ず使うべきlocal_import関数を用意しています。これはその使用例です：

``
mymodule = local_import(mymodule)
``:code

この関数はアプリのローカルモジュールフォルダにおいて``mymodule``を探し、イコールの左側にある名前とともにインポートします。

この関数は、``name``、``reload``、``app``という3つの引数を取ります。``reload=True``と指定するときは、各リクエストにおいてモジュールが再インポートされます。そうしないと、pythonのプロセスはモジュールを一回しかインポートしません。デフォルトは``reload=False``です。開発段階では、``reload=True``に設定すると便利です。なぜなら、モジュールへの修正が、再起動なしに直ちに有効になるからです。しかし、リクエストごとに再インポートすることはパフォーマンスを低下させます。したがって、本番環境では、reload=Falseにすることをお勧めします。

この関数の目的は単一のサーバー上で複数のweb2pyインスタンスを実行する際に、モジュールのパスを``sys.path``に追加したり、定義した順番に依存して参照させたくないからです。

### 実行環境
``exec_environment``:inxx

-----
ここで議論されてるすべてのものは正しく動きますが、代わりに、第13章で説明するコンポーネントを使用してアプリケーションを構築することをお勧めします。
-----

web2pyのモデルとコントローラのファイルはPythonの``import``文を使用してインポートできないという点でPythonモジュールではありません。この理由は、モデルとコントローラが、準備された環境で実行されるように設計されているためです。その環境ではweb2pyのグローバルオブジェクト((request、response、session、cache、T)とヘルパー関数が予め投入されています。これは、Pythonが静的(構文)スコープの言語であるために必要です。そのとき、web2pyの環境は動的に作られます。

web2pyは``exec_environment``関数を用意して、モデルとコントローラに直接アクセスすることを可能にしています。``exec_environment``は、web2pyの実行環境を作り出し、ファイルをそれにロードし、その環境を格納するStorageオブジェクトを返します。Storageオブジェクトはまた、名前空間の機構として機能します。この実行環境で実行されるように設計された任意のPythonファイルは、``exec_environment``を使って呼び出すことができます。``exec_environment``には次のような利用方法があります：
- 他のアプリケーションからのデータ(モデル)にアクセスします。
- 他のモデルやコントローラからグローバルオブジェクトにアクセスします。
- 他のコントローラからコントローラの関数を実行します。
- サイト全体のヘルパーライブラリをロードします。

この例では、``cas``アプリケーションの``user``テーブルから、行が読まれています：
``
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
``:code

もう1つの例：次のコードを含む"other.py"コントローラを想定します：
``
def some_action():
    return dict(remote_addr=request.env.remote_addr)
``:code

このアクションを他のコントローラから(またはweb2pyのシェルから)呼び出す方法は以下の通りです：
``
from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()
``:code

2行目の、``request=request``は省略可能です。これは、現在のリクエストを"other"の環境に渡すことをもたらします。この引数がないと、その環境は、新規の空の(ただし``request.folder``を除く)リクエストオブジェクトを含むようになります。レスポンスやセッションオブジェクトも``exec_environment``に渡すことが可能です。なお、リクエスト、レスポンス、セッションオブジェクトを渡すときは注意してください。呼び出されたアクションによる修正や、呼び出されたアクションにおけるコードの依存性は、予期せぬ副作用につながる可能性があります。

3行目で呼ぶ関数は、ビューを実行しません。つまり、"some_action"で明示的に``response.render``を呼ばない限り、単純に辞書を返します。

最後の注意：``exec_environment``を不適切に使用しないでください。他のアプリケーションのアクションの結果がほしい場合、おそらくXML-RPC APIを実装すべきです(web2pyでXML-RPC APIを実装するのは容易でしょう)。そして、``exec_environment``をリダイレクトの仕組みとして使用しないでください。代わりに``redirect``ヘルパーを使用してください。

### 協調
``cooperation``:inxx

複数のアプリケーションを協調させる方法は多数あります：
- 複数のアプリケーションは同じデータベースに接続することができ、テーブルを共有することができます。データベースのすべてのテーブルをすべてのアプリケーションで定義する必要はありません。しかし、それらを使用するアプリケーションではそれらを定義しなければなりません。同じテーブルを使用するすべてのアプリケーションは、1つを除いて、``migrate=False``に設定してテーブルを定義しなければなりません。
- 複数のアプリケーションは、(第13章で説明する)LOADヘルパーを用いて、他のアクションからのコンポーネントを埋め込むことができます。
- 複数のアプリケーションは、セッションを共有することができます。
- 複数のアプリケーションは、XML-RPCを介してリモートで互いのアクションを呼び出すことができます。
- 複数のアプリケーションは、ファイルシステム(それらが同一のファイルシステムを共有すると仮定)を介して互いのファイルにアクセスすることができます。
- 複数のアプリケーションは、互いのアクションを、前述のようにexec_environmentを用いて、ローカルに呼ぶ出すことができます。
- 複数のアプリケーションは、説明した構文を用いて、互いのモジュールをインポートすることができます：
- 複数のアプリケーションは、``PYTHONPATH``の検索パス、つまり、``sys.path``内にある任意のモジュールをインポートすることができます。

アプリは他のアプリのセッションを次のようなコマンドで読み込むことができます：

``
session.connect(request, response, masterapp='appname', db=db)
``:code

ここで、"appname"は、クッキーに最初のsession_idを設定するマスターアプリケーションの名前です。``db``はセッションテーブル(``web2py_session``)を含むデータベースへのデータベース接続です。セッションを共有するすべてのアプリは、セッションストレージとして同じデータベースを使用する必要があります。

アプリケーションは、次のようにして、他のアプリのモジュールをロードすることができます。

``
othermodule = local_import('othermodule',app='otherapp')
``:code

-------
もしモジュール関数がコアオブジェクト(request、response、session、cache、T)にアクセスする必要がある場合、そのオブジェクトは明示的に関数に渡される必要があります。モジュールがコアオブジェクトの別のインスタンスを作成するようにはしないでください。そうしないと、関数は期待どおりに動作しないでしょう。
-------

### ''WSGI''
``WSGI``:inxx

web2pyとWSGIは愛憎の関係にあります。私たちの観点では、WSGIは、ポータブルな方法でWebサーバーがWebアプリケーションに接続するためのプロトコルとして開発されたものと見ていて、私たちはそれをその目的で使用しています。web2pyはコア部分において1つのWSGIアプリケーションです：``gluon.main.wsgibase``。一部の開発者は、WSGIをミドルウェア通信プロトコルとしての限界へと推し進め、Webアプリケーションを多数の層からなるたまねぎのように開発しています(各層は、全体的なフレームワーク上で独立に開発されたWSGIミドルウェアからなります)。web2pyはこのような構造を内部で採用していません。これは、フレームワークのコアとなる機能(クッキーやセッション、エラー、トランザクション、ディスパッチの処理)は、それらを1つの包括的な層で扱ったほうが、速度とセキュリティの面でよりよく最適化できると、私たちは感じているからです。

それでもなお、web2pyではサードパーティのWSGIアプリケーションとミドルウェアは、次の3通りの方法で(もしくはそれらの組み合わせで)、使用することができます。
- "wsgihandler.py"ファイルを編集し、任意のサードパーティ製のWSGIミドルウェアを取り込むことができます。
- アプリケーション内の任意の指定したアクションに対し、サードパーティ製のWSGIミドルウェアを接続することができます。
- アクションからサードパーティ製のWSGIアプリを呼び出すことができます。

唯一の制限は、サードパーティ製のミドルウェアを用いてweb2pyのコア機能を置き換えることはできないことです。

#### 外部ミドルウェア

"wsgibase.py"ファイルを考慮します：
``
#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase
``:code

``LOGGING``が``True``に設定されているとき、``gluon.main.wsgibase``はミドルウェアの関数``gluon.main.appfactory``によってラップされます。それにより"httpserver.log"ファイルへのロギング機能が提供されます。同じようにして、任意のサードパーティ製のミドルウェアを追加することができます。詳細については、公式のWSGIドキュメントを参照してください。

#### 内部ミドルウェア

コ ントローラの任意のアクション(たとえば``index``)と任意のサードパーティ製のミドルウェアのアプリケーション(たとえば、出力を大文字に変換する``MyMiddleware``)が与えられたとき、web2pyのデコレータを用いて、ミドルウェアをそのアクションに適用することができます。これはその例です:
``
class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self,environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'
``:code

すべてのサードパーティ製のミドルウェアが、このメカニズムで動作することは保障できません。

#### ''WSGI''アプリケーションの呼び出し

WSGIアプリをweb2pyアクションから呼び出すことは簡単です。これはその例です:
``
def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that call the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()
``:code

この場合、``index``アクションは``test_wsgi_app``を呼んで、戻り値を返す前にそれをエスケープします。``index``自身はWSGIアプリではなく、普通のweb2pyのAPI(ソケットに書き込む``response.write``など)を使用する必要があります。
