## フォームとバリデータ

web2pyでフォームを構築するには以下の4通りの方法があります：
- ``FORM`` はHTMLヘルパに関して低レベルの実装を提供します。FORMオブジェクトはHTMLへとシリアライズすることができ、そこに含まれるフィールドについて把握しています。``FORM``オブジェクトは送信フォームの値を検証することができます。
- ``SQLFORM`` は、作成、更新、削除のフォームを、既存のデータベーステーブルから構築するための高レベルのAPIを提供します。
-``SQLFORM.factory``は``SQLFORM``の上にある抽象化レイヤです。データベースが用意されてない場合でもフォーム生成機能を活用できるようにしています。これは、テーブルの記述から``SQLFORM``ととても良く似たフォームを生成します。ただしデータベース・テーブルを作成する必要はありません。
- ``CRUD``メソッド。SQLFORMと同等でSQLFORMに基づく関数が用意されていますが、よりコンパクトな表記が可能になります。

これらすべてのフォームは自分自身を把握しており、入力が検証を通らなかった場合、自分自身を修正してエラーメッセージを加えることができます。フォームでは、検証によって生成された検証済み変数とエラーメッセージを問い合わせることができます。

任意のHTMLコードは、ヘルパを用いて、フォームへ挿入、また、フォームから抽出することができます。

### ``FORM``
``form``:inxx ``accepts``:inxx ``formname``:inxx

次のような"default.py"コントローラを持つ**test**アプリケーションを考えます：
``
def display_form():
    return dict()
``:code

関連付けるビュー"default/display_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

これは、ユーザー名の尋ねる一般的なHTMLフォームです。このフォームを入力しサブミット・ボタンをクリックすると、フォームは自分自身をサブミットし、``request.vars.name``変数とその値が下部に表示されます。

同じフォームをヘルパを用いて生成することができます。これは、ビュー、または、アクションにおいて行うことができます。web2pyはフォームの処理をアクションにおいて行うので、フォームをアクションで定義しても差し支えありません。

これが新しいコントローラです：
``
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

以前のコードは上のコードと等しいです。しかし、フォームは、``FORM``オブジェクトをシリアライズする``{{=form}}``という文によって生成されています。

次に、フォームの検証と処理を追加して、一段複雑なものを加えます。

コントローラを以下のように変更します：
``
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request.vars, session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
``:code

以下のことに注意してください：
- アクションでは、入力フィールド"name"に対して``requires=IS_NOT_EMPTY()``バリデータを加えています。
- アクションでは、``form.accepts(...)``の呼び出しを加えています。
- ビューでは、フォームと``request.vars``とともに``form.vars``と``form.errors``を表示しています。

すべての作業は、``form``オブジェクトの``accepts``メソッドによって行われます。これは、``request.vars``を、(バリデータによって表現された)宣言された要求に従って、フィルタします。``accepts``は、検証を通ったこれらの変数を``form.vars``に格納します。フィールドの値が何かしら要求を満たさない場合は、失敗したバリデータがエラーを返し、そのエラーが``form.errors``に格納されます。``form.vars``と``form.errors``は両方とも、``request.vars``に似た``gluon.storage.Storage``オブジェクトです。前者は、次のように検証を通った値を保持します：
``
form.vars.name = "Max"
``:code

後者は、次のようにエラーを保持します：
``
form.errors.name = "Cannot be empty!"
``:code

``accepts``メソッドのすべての用法は以下の通りです：
``onvalidation``:inxx
``
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
``:code

これらオプション・パラメータの意味は、次の小節で説明します。

``accepts``関数はフォームが受理されたときに``True``を返し、そうでない場合は``False``を返します。フォームは、エラーがある場合か、サブミットされてない場合(たとえば、最初に表示されるとき)には受理されません。

次に示すのは、このページが最初に表示されたときの様子です：

[[image @///image/en6500.png center 300px]]

無効なサブミットをしたときの様子です：

[[image @///image/en6600.png center 300px]]

有効なサブミットをしたときの様子です：

[[image @///image/en6700.png center 300px]]

#### 隠しフィールド

上記のフォーム・オブジェクトが``{{=form}}``によってシリアライズされたとき、``accepts``メソッドに対する前述の呼び出しがあるために、フォームは次のようになります：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

注意する点は、2つの隠しフィールド"_formkey"と"_formname"があることです。これらの存在は、``accepts``の呼び出しによって引き起こされたもので、2つの異なる重要な役割を果たします：
- "_formkey"という隠しフィールドは一度限りのトークンで、web2pyがフォームの二重投稿を防ぐために用いられます。このキーの値はフォームがシリアライズされたときに生成され、``session``に保存されます。フォームがサブミットされたときに、この値が一致する必要があります。そうでないと``accepts``は、フォームが全くサブミットされてないかのように、エラーなしで``False``を返します。これは、フォームが正しくサブミットされたかどうかをweb2pyが判断できないためです。
- "_formname"という隠しフィールドは、フォームの名前としてweb2pyによって生成されますが、その名前は上書きすることができます。このフィールドは、ページが複数のフォームを含んで処理することを可能にするために必要です。web2pyは、この名前によって異なるサブミットされたフォームを区別します。
- オプション的な隠しフィールドは``FORM(..,hidden=dict(...))``のように指定します。

これらの隠しフィールドの役割と、カスタムフォームと複数のフォームを持つページにおける使用方法は、本章の後半で詳しく説明します。

上記のフォームを空の"name"フィールドでサブミットした場合、フォームは検証を通過しません。フォームが再びシリアライズされるときは、次のように表示されます：
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

シリアライズしたフォームにあるDIVのクラス"error"の存在に注意してください。web2pyはこのエラーメッセージをフォームに挿入し、検証を通過しなかったフィールドについて訪問者に知らせます。サブミットの際の``accepts``メソッドは、フォームがサブミットされたかどうかを判断し、フィールド"name"が空でないか、また、それが要求されているかをチェックし、最終的に、バリデータからフォームにエラーメッセージを挿入します。

基底の"layout.html"ビューは、DIVクラスの"error"を処理することが想定されいます。デフォルトのレイアウトはjQueryのエフェクトを使用して、エラーを可視化し、赤い背景とともにスライドダウンさせます。詳細は第10章を参照してください。

#### ``keepvalues``

``keepvalues``:inxx

オプション引数``keepvalues``は、フォームが受理され、かつ、リダイレクトがないときに、web2pyに何をするか知らせ、同じフォームが再び表示されるようにします。デフォルトではすべてクリアされます。``keepvalues``が``True``の場合、フォームは前回挿入した値を事前に入力します。これは、複数の似たレコードを繰り返し挿入するために使用することを想定したフォームがあるときに便利です。``dbio``引数が``False``の場合、web2pyは、フォームを受理した後、いかなるDBの挿入/更新も行いません。``hideerror``が``True``でフォームにエラーが含まれている場合、フォームがレンダリングされたときにエラーは表示されません(``form.errors``をどのように表示するかは開発者次第です)。``onvalidation``引数は以下に説明します。

#### ``onvalidation``
``onvalidation``引数は``None``もしくは、フォームを受け取り何も返さない関数をとることができます。そのような関数は、検証(が通った)直後に、かつ、それ以外のことが発生する前に呼ばれ、フォームを渡します。この関数の目的は複数あります。これは、たとえば、追加的なフォームのチェックを実行したり、最終的にフォームにエラーを加えたりすることができます。これはまた、いくつかのフィールドの値を、他のフィールドの値に基づいて計算するのに使用することもできます。これを用いて、レコードが作成/更新される前にいくつかのアクション(emailの送信など)を引き起こすことも可能です。

以下がその例です。
``
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.accepts(request.vars, session,
                   onvalidation=my_form_processing)
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)
``:code

フォームとリダイレクト

フォームを使用する最も一般的な方法は、自己サブミットを介して、サブミットされたフィールドの変数が、フォームを生成したものと同じアクションによって処理されるようにすることです。フォームが一旦受理されれば、現在のページを再び表示することはあまりありません(ここでは説明を単純にするためいくつか行っています)。訪問者を"next"ページへリダイレクトさせるのがより一般的です。

ここでは新しいコントローラの例を示します：
``
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request.vars, session):
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
``:code

現在のページの代わりにnextページでflashを設定するために、``session.flash``を``response.flash``の代わりに設定する必要があります。web2pyはリダイレクト後、前者を後者に移します。``session.flash``は``session.forget()``を使用していない必要があることに注意してください。

#### ページ毎に複数のフォーム

この節の内容は、FORMとSQLFORMオブジェクトどちらにも適用されます。

ページ毎に複数のフォームを持つことが可能です。しかし、web2pyにそれらを区別できるようにしなければなりません。異なるテーブルの``SQLFORM``によって生成されたものならば、web2pyは異なる名前を自動的にそれらに与えます。それ以外の場合は、異なるフォームの名前を明示的に与えなければなりません。さらに、同一のページに複数のフォームが存在する場合は、重複したサブミッションを防ぐ仕組みが妨げられるので、``accepts``呼び出し時に``session``引数を除外しなければなりません。以下がその例です。
``
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.accepts(request.vars, formname='form_one'):
        response.flash = 'form one accepted'
    if form2.accepts(request.vars, formname='form_two'):
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
``:code

ここに生成された出力を示します：

[[image @///image/en6800.png center 300px]]

訪問者が空のform1をサブミットした場合、form1のみがエラーを表示します。一方、訪問者が空のform2をサブミットした場合、form2のみがエラーメッセージを表示します。

#### フォームの共有

この節の内容は、``FORM``と``SQLFORM``オブジェクトどちらにも適用されます。ここで説明することは可能ですが推奨されません。自己サブミットするフォームを持つことがベストプラクティスだからです。しかし、場合によっては、フォームを送受信するアクションが異なるアプリケーションに属していて、選択肢がないことがあります。

異なるアクションへサブミットするフォームを生成することは可能です。これは、``FORM``または``SQLFORM``オブジェクトの属性において、処理するアクションのURLを指定することで行われます。例:
``
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.accepts(request.vars, formname=None):
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
``:code

"page_one"と"page_two"は両者とも同じ``form``を利用していて、同じことの繰り返しを避けるために、そのフォームをすべてのアクションの外側で一度だけ定義していることに注意してください。コントローラの冒頭にある共通のコード部分は、アクションの呼び出しに制御を渡す前に毎回実行されます。

"page_one"``accepts``を呼び出さないため、formには名前がなくキーもありません。そのため、``accepts``には``session``を渡してはならず、 ``formname=None``を設定する必要があります。そうでないと、フォームは"page_two"に受け取られたときに検証を行いません。

### ``SQLFORM``

次の段階に進んで、以下のようなアプリケーションのモデルファイルを用意します：
``
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
``:code

コントローラを以下のように変更します：
``
def display_form():
   form = SQLFORM(db.person)
   if form.accepts(request.vars, session):
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
``:code

ビューを変更する必要はありません。

コントローラでは、``FORM``を構築する必要はありません。なぜなら、``SQLFORM``は、モデルに定義された``db.person``テーブルからそれを構築するからです。この新しいフォームがシリアライズされると次のように表示されます：
``
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
``:code

この自動的に生成されたフォームは、前述の低レベルのフォームよりも複雑です。第1に、これはテーブルの行を含み、各行は3つのカラムを持っています。最 初のカラムはフィールドの名前を保持しています(``db.person``から決定されます)。第2のカラムは入力フィールドを保持します(最終的にエラーメッ セージも保持します)。第3のカラムは省略可能で空になっています(``SQLFORM``のコンストラクタにおいてフィールドを用いて入力される可能性がありま す)。

フォームのすべてのタグには、テーブルとフィールドの名前に由来する名前が付けられています。これによりCSSとJavaScriptを用いてフォームをカスタマイズするのが容易になります。この機能については、第10章で詳しく説明します。

ここでより重要なのは、``accepts``メソッドがより多くの仕事をすることです。前回の場合と同様、入力の検証を行いますが、加えて、入力が検証を通ったら、データベースに対して新規レコードの挿入を実行し、``form.vars.id``に新規レコードのユニークな"id"を格納します。

``SQLFORM``オブジェクトはまた、自動的に"upload"フィールドを処理し、アップロードしたファイルを"uploads"フォルダに保存します(競合を避けるた め安全にリネームして、ディレクトリ・トラバーサル攻撃を防いだ後に保存します)。そして、(新しい)ファイル名をデータベースの適切なフィールドに保存 します。

``SQLFORM``は、"boolean"の値をチェックボックスで、"text"の値をテキストエリアで、限定したセットまたはデータベース内に含まれることを要求された値をドロップボックスで、"upload"フィールドをアップロードしたファイルをダウンロードできるようにしたリンクで、表示します。"blob"フィールドは非表示します。後述しますが、異なる方法で処理されることになるからです。

たとえば、次のモデルを考えてください：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
``:code

この場合、``SQLFORM(db.person)``は次に表示されるようなフォームを生成します：

[[image @///image/en6900.png center 300px]]

``SQLFORM``のコンストラクタは、さまざまなカスタマイズを可能にします。たとえば、フィールドの一部のみを表示したり、ラベルを変更したり、オプション的な第3のカ ラムに値を加えたり、現在のINSERTフォームとは対照的にUPDATEとDELETEフォームを作成したりすることができます。``SQLFORM``はweb2pyにおいて、最も大きく時間を節約する単一のオブジェクトです。

``SQLFORM``クラスは"gluon/sqlhtml.py"に定義されています。これは、``xml``メソッドをオーバライドして簡単に拡張することができます。このメソッドはこのオブジェクトをシリアライズして、その出力を変更します。

``fields``:inxx ``labels``:inxx
``SQLFORM``のコンストラクタの用法は以下の通りです：
``
SQLFORM(table, record=None, deletable=False,
        linkto=None, upload=None, fields=None, labels=None, col3={},
        submit_button='Submit', delete_label='Check to delete:',
        id_label='Record id: ', showid=True,
        readonly=False, comments=True, keepopts=[],
        ignore_rw=False, formstyle='table3cols',**attributes)
``:code
- オプション的な第2の引数は、INSERTフォームから、指定したレコードに対するUPDATEフォームに切り替えます(次の小節を参照してください)。
- ``showid``:inxx ``delete_label``:inxx ``id_label``:inxx ``submit_button``:inxx``deletable``が``True``の場合、UPDATEフォームは"Chceck to delete"というチェックボックスを表示します。フィールドがある場合、このラベルの値は``delete_label``引数を介して設定されます。
- ``submit_button``はサブミット・ボタンの値を設定します。
- ``id_label``はレコードの"id"のラベルを設定します。
- ``showid``が``False``の場合、レコードの"id"は表示されません。
- ``fields``は表示したいフィールド名のオプション的なリストです。リストが提供されている場合、リスト内のフィールドしか表示されません。例:
``
fields = ['name']
``:code
-  ``labels``はフィールドラベルの辞書です。辞書のキーはフィールド名で、対応する値はラベルとして表示されるものです。ラベルが提供されていない場合、web2pyはラベルをフィールド名から生成します(フィールド名を大文字で書き始めアンダースコアをスペースに置換します)。例:
``
labels = {'name':'Your Full Name:'}
``:code
- ``col3``は第3のカラム用の辞書の値です。例:
``
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
``:code
- ``linkto``と``upload``は、ユーザー定義コントローラへのオプション的なURLです。これにより、フォームで参照フィールドを扱うことが可能になります。これについては、後述の節で詳説します。
- ``readonly``。Trueの場合、読み取り専用のフォームを表示します。
- ``comments``。Falseの場合、col3のコメントを表示しません。
- ``ignore_rw``。通常は、作成/更新フォームに対して、writable=Trueでマークされたフィールドしか表示されず、読み取り専用フォーｍに対しては、readable=Trueでマークしたフィールドしか表示されません。``ignore_rw=True``に設定すると、これらの制約は無視され、すべてのフィールドが表示されます。これは主に、appadmineインターフェースにおいて。モデルの意図を覆して、各テーブルのすべてのフィールドを表示するために使用されます。
- ``formstyle``:inxx ``formstyle``フォームをhtmlにシリアライズするときに使用されるスタイルを決めます。次の値をとることができます："table3cols"(デフォルト)、"table2cols"(一行にラベルとコメントを、もう1つの行に入力を表示します)、"ul"(入力フィールドの順序なしリストを作成します)、"divs"(フォームをcssフレンドリなdivで表現します)。 ``formystyle``はまた、(record_id, field_label, field_widget, field_comment)を属性として受け取り、TR()オブジェクトを返す関数をとることもできます。
- オプション的な``attributes``は、``SQLFORM``オブジェクトをレンダリングする``FORM``タグに対して渡したいアンダースコアで始まる引数群です。たとえば次のようになります：
``
_action = '.'
_method = 'POST'
``:code

特別な``hidden``属性があります。辞書が``hidden``として渡されたとき、その項目は"hidden"INPUTフィールドに変換されます(第5章の``FORM``ヘルパの例を参照してください)。

#### ``SQLFORM``と``insert``/``update``/``delete``

レコードを第2のオプション引数として``SQLFORM``のコンストラクタに渡した場合、フォームは、そのレコードのためのUPDATEフォームになります。これは、フォームがサブミットされたとき、既存のレコードがアップロードされ、どの新規のレコードも作成されないことを意味します。``deletable=True``として引数を設定すると、UPDATEフォームは"check to delete"というチェックボックスを表示します。これがチェックされていると、レコードは削除されます。

たとえば、前述の例のコントローラを修正し、次のように、URLのパスにおけて追加の整数引数を渡すことができます。
``
/test/default/display_form/2
``:code

これに対応するidを持つレコードがあると、``SQLFORM``は、このレコードのためのUPDATE/DELETEフォームを生成します：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.accepts(request.vars, session):
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

2行目でレコードを見つけ、3行目でUPDATE/DELETEフォームを作り、4行目はすべての対応するフォームの処理を行います。

------
更新フォームは作成フォームにとても似ていますが、現在のレコードによって事前入力され、プレビュー画像も表示します。デフォルトでは、``deletable = True``になっていて、"delete record"オプションが更新フォームに表示されます。
------

編集フォームはまた、``name="id"``という隠れINPUTフィールドを保持しています。これによりレコードが特定できるようになります。このidはまた、追加のレキュリティのためサーバーサイドで保存され、訪問者がフィールドの値を改ざんした場合、UPDATEは実行されず、web2pyは"user is tampering with form"となるSyntaxErrorを発生させます。

Fieldが``writable=False``としてマークされていると、フィールドは作成フォームに表示されず、読み込み専用の更新フォームで表示されます。フィールドが``writable=False``、かつ、``readable=False``としてマークされていて場合、フィールドは、更新フォームを含めすべてにおいて表示されません。

次のように作成されたフォームは、
``
form = SQLFORM(...,ignore_rw=True)
``:code

``readable``と``writable``の属性を無視して、常にすべてのフィールドを表示します。``appadmin``のフォームはデフォルトでそれらを無視します。

次のように作成されたフォームは、
``
form = SQLFORM(table,record_id,readonly=True)
``:code

常に、読み取り専用モードですべてのフィールドを表示し、受理することはありません。

#### HTMLにおける``SQLFORM``

``SQLFORM``のフォームをその生成と処理機能から利便を享受するために使用したいが、``SQLFORM``オブジェクトのパラメタでは達成できなくらいのHTMLのカスタマイズが必要で、HTMLを用いてフォームを設計しなければならないことがあります。

では、前回のコントローラを編集し新しいアクションを追加してみます：
``
def display_manual_form():
   form = SQLFORM(db.person)
   if form.accepts(request.vars, formname='test'):
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill the form'
   return dict()
``:code

そして、関連付けられたビュー"default/display_manual_form.html"にフォームを挿入します：
``
{{extend 'layout.html'}}
<form>
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
``:code

ここで、アクションはフォームを返していないことに注意してください。なぜならビューに渡されないからです。ビュー はHTMLにおいて手動で作成されたフォームを含んでいます。フォームは、隠れフィールド"_formname"を含んでいて、それはアクションの ``accepts``の引数で指定されたformnameと必ず同じにしなければなりません。web2pyは同じページに複数のフォームがある場合に、どれから サブミットされたかを判断するのに、フォームの名前を使用します。ページが単一のフォームからなる場合、``formname=None``と設定して、ビューにおける隠れフィールドを見送ることができます。

#### ``SQLFORM``とアップロード

"upload"型のフィールドは特殊です。それらは、``type="file"``のINPUTフィールドでレンダリングされます。特に指定がない限り、アップロードしたファイルはバッファにストリームされ、自動的に割り当てられる新しい安全な名前を用いて、アプリケーションの"upload"フォルダに保存されます。このファイルの名前はこのとき、アップロード型のフィールドに保存されます。

例として、次のモデルを考えてください：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
``:code

上記のコントローラのアクション"display_form"と同じものを利用することができます。

新規のレコードを挿入するとき、フォームはファイルに対する閲覧を可能にします。たとえば、jpg画像を選択してください。このファイルはアップロードされ、次のように保存されます：
``
applications/test/uploads/person.image.XXXXX.jpg
``:code

"xxxxxx"は、web2pyによってこのファイルに割り当てられるランダムな識別子になります。

``content-disposition``:inxx

-------
デフォルトでは、アップロードしたファイルの元のファイル名はb16エンコードされ、そのファイルに対する新しい名前の構築に使用されることに注意してください。この名前は、デフォルトの"download"アクションによって取り出され、元のファイルへのContent-Dispositionヘッダを設定するのに使用されます。
-------

拡張子だけがそのままになります。これはセキュリティ上の理由です。なぜなら、ファイル名は特別な文字列を含む可能性があり、訪問者にディレクトリ・トラバーサル攻撃や他の悪意のある操作を許してしまうからです。

新しいファイル名は``form.vars.image``にも格納されます。

UPDATEフォームを使用してレコードを編集するとき、既存のアップロードしたファイルへのリンクを表示するのはいいことで、web2pyはその方法を提供しています。

URLをupload引数を介して``SQLFORM``のコンストラクタに渡す場合、web2pyは、ファイルをダウンロードするために、そのURLのアクションを用います。次のアクションを考えてください：
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.accepts(request.vars, session):
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
``:code

さて、次のURLにて新規のレコードを挿入してみます：
``
http://127.0.0.1:8000/test/default/display_form
``:code

画像をアップロードして、フォームをサブミットして、次のURLを訪れて新しく作られたレコードを編集します：
``
http://127.0.0.1:8000/test/default/display_form/3
``:code

(ここでは最新のレコードがid=3をもつと仮定します)。フォームは以下に示すように画像のプレビューを表示します：

[[image @///image/en7000.png center 300px]]

このフォームは、シリアライズされるときに、次のようなHTMLを生成します：
``
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
``:code

これは、アップロードしたファイルをダウンロードできるようにするリンクと、データベースのレコードからこのファイルを削除するためのチェックボックスを含んでいます。したがって、"image"フィールドにはNULLが格納されています。

なぜ、このような機構が公開されているのでしょうか？なぜ、ダウンロード関数を書く必要があるのでしょうか？なぜなら、いくつかの認証メカニズムをダウンロード関数に課すことが必要になるかもしれないからです。例は、第8章を参照してください。

#### 元のファイル名の保存

web2pyは自動的に元のファイル名を新しいUUIDのファイル名の中に保存し、ファイルがダウンロードされたときにそれを取り出します。ダウンロードの際、オリジナルのファイル名は、HTTPレスポンスの Content-Dispositionヘッダに格納されます。これはすべて、プログラミングの必要なしに透過的に行われます。

時には、オリジナルのファイル名をデータベースのフィールドに保存したい場合もあります。この場合、モデルを修正し、それを保存するフィールドを加える必要があります：
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
``:code

このとき、それを処理するようにコントローラーを次のように修正する必要があります：
``
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image:
        form.vars.image_filename = request.vars.image.filename
    if form.accepts(request.vars, session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

``SQLFORM``は"image_filename"フィールドを表示していないことに注意してください。"display_form"アクションは、``request.vars.image``のファイル名を``form.vars.image_filename``に移動します。これにより、``accepts``においてそれを処理し、データベースに保存することができるようになります。ダウンロード関数は、そのファイルを配信する前に、元のファイル名をデータベースにおいてチェックし、Content-Dispositionヘッダにおいて使用します。

#### ``autodelete``
``autodelete``:inxx

レコードを削除する際に、``SQLFORM``はレコードによって参照された物理的なアップロード・ファイルを削除することはありません。その理由は、web2pyがそのファイルが他のテーブルによって使用/リンクされているか、また、他の目的でしようされているかどうか知ることができないからです。対応するレコードが削除されたとき、実際のファイルを削除しても安全だと判断できる場合は、次のようにしてそうすることができます：
``
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('file','upload',autodelete=True))
``:code

``autodelete``属性はデフォルトでは``False``です。``True``に設定すると、レコードが削除されるとき、ファイルも削除されるようになります。

#### 参照レコードへのリンク

今度は、参照フィールドによってリンクされた2つのテーブルを考えます。
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', db.person),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')
``:code

personはdogsを持ち、各dogは所有者(owner)、つまり、personに所属しています。dogの所有者(owner)には、有効な``db.person.id``を``'%(name)s'``を用いて参照することが要求されます。

このアプリケーションの**appdadmin**インターフェースを用いて、何人かのpersonと彼らのdogsを加えましょう。

既存のpersonを編集するとき、**appadmin**のUPDATEフォームは、このpersonに属するdogsの一覧を表示するページへのリンクを表示します。この挙動は、``SQLFORM``の``linkto``引数を用いて真似することができます。``linkto``は、``SQLFORM``からのクエリ文字列を受け取って対応するレコードを返す新規のアクションのURLを指す必要があります。以下がその例です。
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records')
   form = SQLFORM(db.person, records, deletable=True,
                  upload=url, linkto=link)
   if form.accepts(request.vars, session):
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

これがそのページです：

[[image @///image/en7100.png center 300px]]

"dog.owner"というリンクがあります。このリンクの名前は、次のような``SQLFORM``の``labels``引数を介して変更することができます：
``
labels = {'dog.owner':"This person's dogs"}
``:code

リンクをクリックすると、次の場所に向かいます：
``
/test/default/list_records/dog?query=dog.owner%3D5
``:code

"list_records"は指定されたアクションで、``request.args(0)``に参照するテーブルの名前が設定され、``request.vars.query``にSQLのクエリ文字列が設定されています。URLのクエリ文字列は適切にurlエンコードされた"dog.owner=5"の値を含んでいます(web2pyはURLを解析するときに自動的にこれをデコードします)。

とても汎用的な"list_records"アクションを次のように簡単に実装することができます：
``
def list_records():
    table = request.args(0)
    query = request.vars.query
    records = db(query).select(db[table].ALL)
    return dict(records=records)
``:code

関連付けられるビュー"default/list_records.html"は次のようにします：
``
{{extend 'layout.html'}}
{{=records}}
``:code

選択によってレコードセットが返され、ビューでシリアライズされるとき、これは最初にSQLTABLEオブジェクト(Tableと同じではありません)に変換された後、各フィールドがテーブルのカラムと対応するHTMLテーブルへとシリアライズされます。

#### フォームの事前入力
次の構文を用いて、フォームを事前入力することは常に可能です：
``
form.vars.name = 'fieldvalue'
``:code

上記のような文は、フィールド(この例では"name")が明示的にフォームで表示されるかにかかわらず、フォームの宣言の後、かつ、フォームの受理の前に挿入される必要があります。

#### データベースIOなしの``SQLFORM``

``SQLFORM``を使用してデータベーステーブルからフォームを生成し、サブミットしたフォームをそのまま検証するが、データベースにおいて自動的なINSERT/UPDATE/DELTEを行いたくない場合があります。たとえば、1つのフィールドが他の入力フィールドから計算される必要がある場合です。また、挿入されたデータに対して標準の検証では達成できない追加の検証を行いたい場合です。

これは、次のものを：
``
form = SQLFORM(db.person)
if form.accepts(request.vars, session):
    response.flash = 'record inserted'
``:code

以下のように分解して簡単に行うことができます。
``
form = SQLFORM(db.person)
if form.accepts(request.vars, session, dbio=False):
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
``:code

同じことはUPDATE/DELETEフォームでも行うことができます。次のものを：
``
form = SQLFORM(db.person,record)
if form.accepts(request.vars, session):
    response.flash = 'record updated'
``:code

以下のように分解します。
``
form = SQLFORM(db.person,record)
if form.accepts(request.vars, session, dbio=False):
    if form.vars.get('delete_this_record', False):
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'
``:code

両者の場合でも、web2pyはアップロードファイルの保存とリネームを、``dbio=True``のように、つまりデフォルトのシナリオのように、処理します。アップロードされたファイル名は以下にあります：
``
form.vars.fieldname
``:code


### ``SQLFORM.factory``

データベース・テーブルを持っているかのようにフォームを生成したいが、データベース・テーブルはいらないような場面があります。見栄えのよいCSSフレンドリなフォームの生成と、おそらくファイルのアップロードとリネームの実行のために、``SQLFORM``の能力を単純に活用したい場面です。

これは``form_factory``を介して行うことができます。ここに、フォームを生成し、検証を行い、ファイルをアップロードし、すべてを``session``に保存するような例を示します。
``
def form_from_factory()
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.accepts(request.vars, session):
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.filename = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

次にビュー"default/form_from_factory.html"を示します：
``
{{extend 'layout.html'}}
{{=form}}
``:code

フィー ルドのラベルにおいてスペースの代わりにアンダースコアを使用するか、``SQLFORM``で行ったのと同様に、``labels``の辞書を``form_factory`` に明示的に渡す必要があります。デフォルトでは、``SQLFORM.factory``は、あたかも"no_table"というテーブルから生成されたフォーム のように生成されたhtmlの"id"属性を用いてフォームを生成します。このダミーテーブルの名前を変更したいときは、factoryの``table_name``属性を用いてください：
``
form = SQLFORM.factory(...,table_name='other_dummy_name')
``:code

factoryから生成された2つのフォームを同じテーブルに配置する必要があり、かつ、CSSの競合を避けたい場合、``table_name``の変更が必要になります。

### CRUD
``CRUD``:inxx ``crud.create``:inxx ``crud.update``:inxx ``crud.select``:inxx ``crud.search``:inxx ``crud.tables``:inxx ``crud.delete``:inxx

web2pyに最近追加されたものの1つは、SQLFORMの上にあるCreate/Read/Update/Delete (CRUD) APIです。CRUDはSQLFORMを作成しますが、フォームの作成、フォームの処理、通知、リダイレクトを、すべて1つの関数において補完することによって、コーディングを単純化します。

初めに注意する点は、CRUDが他のこれまで使用してきたweb2pyのAPIと異なり、APIがすでに公開されていないことです。これはインポートしなければなりません。また、特定のデータベースにリンクする必要があります。例:
``
from gluon.tools import Crud
crud = Crud(globals(), db)
``:code

コンストラクタの最初の引数は現在のコンテキスト``globals()``です。これにより、CRUDがローカルのrequest、response、sessionにアクセスできるようになります。二番目の引数は、データベース接続オブジェクト``db``です。

上で定義した``crud``オブジェクトは次のようなAPIを提供します：

``crud.tables``:inxx ``crud.create``:inxx ``crud.read``:inxx ``crud.update``:inxx ``crud.delete``:inxx ``crud.select``:inxx .
- ``crud.tables()``は、データベースに定義されているテーブルのリストを返します。
- ``crud.create(db.tablename)``は、テーブルのtablenameに対する作成フォームを返します。
- ``crud.read(db.tablename, id)``は、tablenameとレコードidに対する読み取り専用のフォームを返します。
- ``crud.update(db.tablename, id)``は、tablenameとレコードidに対する更新フォームを返します。
- ``crud.delete(db.tablename, id)``は、レコードを削除します。
- ``crud.select(db.tablename, query)``は、テーブルから選択されたレコードのリストを返します。
- ``crud.search(db.tablename)``は、(form, records)のタプルを返します。formは検索フォームで、recordsはサブミットされた検索フォームに基づくレコードのリストです。
- ``crud()``は、``request.args()``に基づいて、上記のうちの1つを返します。

たとえば、次のアクションは：
``
def data: return dict(form=crud())
``:code

次のようなURLを公開します：
``
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
``:code

しかし、次のアクションは：

``
def create_tablename:
    return dict(form=crud.create(db.tablename))
``:code

以下の作成メソッドしか公開しません

``
http://.../[app]/[controller]/create_tablename
``:code

また、次のアクションは：

``
def update_tablename:
    return dict(form=crud.update(db.tablename, request.args(0)))
``:code

以下の更新メソッドしか公開しません

``
http://.../[app]/[controller]/update_tablename/[id]
``:code

他も同様です。

CRUDの挙動は二通りの方法でカスタマイズできます。1つは、``crud``オブジェクトにいくつかの属性を設定することです。もう1つは、各メソッドにさらなるパラメータを渡すことです。

#### 設定

ここに、現在のCRUD属性と、そのデフォルトの値と、意味のリスト一式を示します：

すべてのcrudのフォームに認証をかけます：

``
crud.settings.auth = None
``:code
利用方法は第8章で説明します。

``crud``オブジェクトを返す``data``関数を定義しているコントローラを指定します

``
crud.settings.controller = 'default'
``:code

レコードの"create"が成功した後のりダイレクト先のURLを指定します：

``
crud.settings.create_next = URL('index')
``:code

レコードの"update"が成功した後のりダイレクト先のURLを指定します：

``
crud.settings.update_next = URL('index')
``:code

レコードの"delete"が成功した後のりダイレクト先のURLを指定します：

``
crud.settings.delete_next = URL('index')
``:code

アップロードされたファイルへリンクするために使用するURLを指定します：

``
crud.settings.download_url = URL('download')
``:code

``crud.create``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：

``
crud.settings.create_onvalidation = StorageList()
``:code

``StorageList``は``Storage``オブジェクトと同様で、両者"gluon/storage.py"ファイルに定義されていますが、そのデフォルトは``None``ではなく``[]``になります。これにより、次の構文が使用できます：

``
crud.settings.create_onvalidation.mytablename.append(lambda form:....)
``:code

``crud.update``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：

``
crud.settings.update_onvalidation = StorageList()
``:code

``crud.create``フォームの完了後に実行される追加の関数を指定します：

``
crud.settings.create_onaccept = StorageList()
``:code

``crud.update``フォームの完了後に実行される追加の関数を指定します：

``
crud.settings.update_onaccept = StorageList()
``:code

レコードが削除される場合において、``crud.update``の完了後に実行される追加の関数を指定します：

``
crud.settings.update_ondelete = StorageList()
``:code

``crud.delete``の完了後に実行される追加の関数を指定します：

``
crud.settings.delete_onaccept = StorageList()
``:code

"update"フォームが"delete"ボタンを持つかどうかを決めます：

``
crud.settings.update_deletable = True
``:code

"update"フォームが編集レコードの"id"を表示するかどうかを決めます：

``
crud.settings.showid = False
``:code

フォームが前回挿入された値を維持するか、サブミット成功後デフォルトにリセットするかどうかを決めます：

``
crud.settings.keepvalues = False
``:code

フォームのスタイルは次のようにして変更することができます

``
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
``:code

authで説明されるのと同じやり方で、フォームにキャプチャを加えることができます：

``
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
``:code

#### メッセージ

カスタマイズ可能なメッセージのリストを以下に示します：
``
crud.messages.submit_button = 'Submit'
``:code

これは、create、updateフォーム両方に対して"submit"ボタンのテキストを設定します。
``
crud.messages.delete_label = 'Check to delete:'
``:code

これは、"update"フォームにおいて"delete"ボタンのラベルを設定します。
``
crud.messages.record_created = 'Record Created'
``:code

これは、レコードの作成が成功した際のflashメッセージを設定します。
``
crud.messages.record_updated = 'Record Updated'
``:code

これは、レコードの更新が成功した際のflashメッセージを設定します。
``
crud.messages.record_deleted = 'Record Deleted'
``:code

これは、レコードの削除が成功した際のflashメッセージを設定します。
``
crud.messages.update_log = 'Record %(id)s updated'
``:code

これは、レコードの更新が成功したときのログメッセージを設定します。
``
crud.messages.create_log = 'Record %(id)s created'
``:code

これは、レコードの作成が成功したときのログメッセージを設定します。
``
crud.messages.read_log = 'Record %(id)s read'
``:code

これは、レコードの読み取りアクセスが成功したときのログメッセージを設定します。
``
crud.messages.delete_log = 'Record %(id)s deleted'
``:code

これは、レコードの削除が成功したときのログメッセージを設定します。

なお、``crud.messages``は``gluon.storage.Message``クラスに所属しています。これは、``gluon.storage.Storage``に似ていますが、``T``演算子の必要なしに、自動的にその値を翻訳します。

ログメッセージは、CRUDが第8章で説明するAuthに接続された場合のみ使用されます。イベントは、Authテーブルの"auth_events"にログとして記録されます。

#### メソッド

CRUDのメソッドの挙動は、呼び出し毎の原則でカスタマイズすることができます。ここにその用法を示します：
``
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero)
``:code
- ``table``は、DALのテーブル、または、テーブル名です。メソッドはその上で動作します。
- ``record`` and ``record_id``は、レコードのidです。メソッドはその上で動作します。
- ``next``は、成功後にリダイレクトする先のURLです。URLが部分文字列"[id]"を含む場合、これは、ちょうど作成/更新されたレコードのidによって置換されます。
- ``onvalidation``は、SQLFORM(..., onvalidation)と同じ機能を持ちます。
- ``onaccept``は、フォームのサブミットが受理された後に呼ばれ、そこで、リダイレクトする前に、動作する関数です。
- ``log``はログのメッセージです。CRUDにおけるログのメッセージは、form.varsの辞書変数を"%(id)s"のように参照します。
- ``message``はフォームが受理されたときのflashメッセージです。
- ``ondelete``は、"update"フォームを介してレコードが削除されるときに、onacceptの場所で呼ばれます。
- ``deletable``は、"update"フォームがdeleteオプションを持つかどうかを決めます。
- ``query``は、レコードを選択するために使用するクエリです。
- ``fields``は、レコードを選択するために使用するクエリです。
- ``orderby``は、選択したレコードの順序を決めます(第6章を参照してください)。
- ``limitby``は、表示される選択レコードの範囲を決めます(第6章を参照してください)。
- ``headers``は、テーブルのヘッダの名前からなる辞書です。
- ``queries``は、``['equals', 'not equal', 'contains']``のようなリストです。検索フォームにおける使用可能なメソッドを保持します。
- ``query_labels``は、``query_labels=dict(equals='Equals')``のような辞書です。検索メソッドに対する名前を与えます。
- ``fields``は、検索ウィジェットにおいて列挙されるフィールドのリストです。
- ``field_labels``は、フィールド名をラベルにマッピングする辞書です。
- ``zero``は、デフォルトでは"choose one"で、検索ウィジェットのドロップダウンのためのデフォルトのオプションとして使用されます。

ここでは、単一のコントローラ関数における使用例を示します：
``
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name', 'Name'})
    return dict(form=form, persons=persons)
``:code

もう1つのとても汎用的なコントローラ関数を示します。これにより、任意のテーブルから任意のレコードを検索、作成、編集することができます。このとき、テーブル名はrequest.args(0)によって渡されます：
``
def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id: \
       A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.select(table)
    return dict(form=form,search=search,rows=rows)
``:code

なお、``table.id.represent=...``の行は、web2pyに対して、idフィールドの表現を変更し、代わりに、自分自身のページへのリンクを表示し、作成ページを更新ページに切り替えるためにidをrequest.args(1)として渡すように指示します。

#### レコードのバージョニング

CRUDはデータベースのレコードのバージョニングを行うユーティリティを提供しています：

すべての改訂履歴を必要とするテーブル(db.mytable)を持ちたいなら、次のようにするだけです：
``
  form=crud.update(db.mytable,myrecord,onaccept=crud.archive)
``:code
``crud.archive``は**db.mytable_archive**という新規のテーブルを定義します(この名前は参照するテーブルの名前に由来します)。そして、更新時に、(更新前の)レコードのコピーを、作成した記録用のテーブルに保存します。そのレコードへの参照も含まれます。

レコードは実際に更新されるので(その前回の状態のみが記録されます)、参照が壊れることはありません。

これはすべて内部で行われます。記録テーブルにアクセスしたいならば、モデルにおいてそれを定義しておく必要があります：
``
db.define_table('mytable_history',
   Field('current_record',db.mytable),
   db.mytable)
``:code

なお、テーブルは``db.mytable``を拡張し(そのすべてのフィールドを含み)、current_recordへ参照を追加しています。``current_record``.

crud.archiveは、次のように元のテーブルがtimestampフィールドを持たない限り、保存したレコードのタイムスタンプを取りません。
``
db.define_table('mytable',
    Field('saved_on','datetime',
          default=request.now,update=request.now,writable=False),
    Field('saved_by',auth.user,
          default=auth.user_id,update=auth.user_id,writable=False),
``:code

これらのフィールドに関して何ら特別なことはなく、好きな名前を付けることが可能です。これらはレコードが記録される前に入力され、各レコードのコピーと共に記録されます。記録テーブルの名前、または/かつ、フィールドの名前は次のように変更することができます：

もし履歴テーブルや参照フィールドの名前を変更したいときは、このようにできます：
``
db.define_table('myhistory',
    Field('parent_record',db.mytable),
    db.mytable)
## ...
form = crud.update(db.mytable,myrecord,
                   onaccept=lambda form:crud.archive(form,
                   archive_table=db.myhistory,
                   current_record='parent_record'))
``:code

### カスタムフォーム

フォームがSQLFORMやSQLFORM.factory、CRUDを利用して作られている場合、それをビューに埋め込む方法は複数あり、複数の度合いのカスタマイズができるようになります。たとえば次のモデルを考えてみます：
``
db.define_table('image',
    Field('name'),
    Field('file', 'upload'))
``:code

また、次のアップロード・アクションも考えます：
``
def upload_image():
    return dict(form=crud.create(db.image))
``:code

最も簡単に、``upload_image``に対するビューにおいてフォームを埋め込む方法は次の通りです：
``
{{=form}}
``:code

これは標準のテーブル・レイアウトになります。別のレイアウトを使用したい場合、フォームを要素に分解することができます
``
{{=form.custom.begin}}
Image name: <div>{{=form.custom.widget.name}}</div>
Image file: <div>{{=form.custom.widget.file}}</div>
Click here to upload: {{=form.custom.submit}}
{{=form.custom.end}}
``:code

ここで、``form.custom.widget[fieldname]``は、そのフィールドに対して適切なウィジェットにシリアライズされます。フォームがサブミットされてエラーを含む場合、そのエラーは従来通りウィジェットの下に追加されます。

上記のサンプルフォームは下図のように表示されます。

[[image @///image/en7200.png center 300px]]

ただし、同様の結果は次のようにしても得られます：

``
crud.settings.formstyle='table2cols'
``:code

この場合、カスタムフォームを使用していません。他の可能な``formstyle``は、"table3cols" (デフォルト)、"divs"、"ul"です。

web2pyによってシリアライズされたウィジェットを使用したくない場合は、それをHTMLで置き換えることができます。このために有用ないくつかの変数があります：
- ``form.custom.label[fieldname]``はフィールドのラベルを含みます。
- ``form.custom.dspval[fieldname]``はフィールドの表示方法に関わるform-typeとfield-typeを含みます。
- ``form.custom.inpval[fieldname]``はフィールドの値に関するform-typeとfield-typeを含みます。

以下に説明する慣例に従うことは重要です。

#### CSSの慣例

SQLFORM、SQLFORM.factory、CRUDによって生成されたフォーム内の​​タグは、フォームのさらなるカスタマイズに使用することができる厳密なCSSの命名規則に従っています。

"mytable"テーブルと"string"型の"myfield"フィールドが与えられたとき、次のものによってレンダリングされます。
``
SQLFORM.widgets.string.widget
``:code

これは次のようになります：
``
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
``:code

以下のことに注意してください：
- INPUTタグのクラスはフィールドの型と同じです。これは"web2py_ajax.html"におけるjQueryのコードが機能するのに非常に重要です。これは、"integer"か"double"のフィールドにおいて数値しか持たないようにし、"time"、"date"、"datetime"のフィールドではポップアップのカレンダーが表示されるようにします。
- idは、クラスの名前とフィールドの名前をアンダースコアで結合したものです。これにより、たとえば``jQuery('#mytable_myfield')``のようにして一意に参照することができ、フィールドのスタイルシートを操作したり、フィールドのイベントに関連付けられたアクション(focus、blur、keyupなど)をバインドすることができるようになります。
- nameは、想像通り、フィールド名になります。

#### エラーの非表示
``hideerror``:inxx

場合によっては、自動的なエラー配置を無効にして、フォームのエラーメッセージをデフォルトではないどこか別の場所に表示したいことがあります。これを行うのは簡単です。

- FORMまたはSQLFORMの場合は、``hideerror=True``を``accepts``メソッドに渡してください。
- CRUDの場合は、``crud.settings.hideerror=True``に設定してください。

エラーを表示するビューを変更したくなることもあります(もはや自動的に表示されないので)。

次の例では、エラーをフォームの中ではなく、フォームの上に表示されるようにしています。
``
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
``:code

エラーは下図のように表示されます：

[[image @///image/en7300.png center 300px]]

このメカニズムはカスタムフォームでも動作します。


### バリデータ
``validators``:inxx

バリデータは入力フィールド(データベース・テーブルから生成されたフォームを含む)を検証するために使用するクラスです。

``FORM``とともにバリデータを使用する例です：
``
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
``:code

どのようにテーブルのフィールドに対するバリデータを要求するかの例です：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
``:code

バリデータは常にフィールドの``requires``属性を用いて割り当てられます。フィールドは、単一もしくは複数のバリデータを持つことができます。複数のバリデータはリストの一部になります：
``
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
``:code

バリデータは``FORM``上の``accepts``関数や、フォームを含む他のHTMLヘルパーオブジェクトによって呼ばれます。それらは、列挙されている順序で呼ばれます。

組み込みのバリデータはオプション引数を取るコンストラクタを持っています：

``
IS_NOT_EMPTY(error_message=T('cannot be empty'))
``:code

``error_message``は、任意のバリデータに対してデフォルトのエラーメッセージをオーバーライドするようにします。

データベース・テーブルに対するバリデータの例です：
``
db.person.name.requires = IS_NOT_EMPTY(error_message=T('fill this!'))
``:code

ここで、国際化対応のため``T``という翻訳演算子を使用しています。なお、デフォルトのエラーメッセージは翻訳されません。

#### バリデータ

##### ``IS_ALPHANUMERIC``
``IS_ALPHANUMERIC``:inxx

このバリデータは、フィールドの値がa～z、A～Z、0～9の範囲にある文字しか含まれていないことをチェックします。
``
requires = IS_ALPHANUMERIC(error_message=T('must be alphanumeric!'))
``:code

##### ``IS_DATE``
``IS_DATE``:inxx

このバリデータは、指定したフォーマットで有効な日付がフィールドの値に入っていることをチェックします。異なるローケルで異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
``
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message=T('must be YYYY-MM-DD!'))
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DATE_IN_RANGE``
``IS_DATE_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
``
requires = IS_DATE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message=T('must be YYYY-MM-DD!'))
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DATETIME``
``IS_DATETIME``:inxx

このバリデータは、指定したフォーマットで有効な日時がフィールドの値に入っていることをチェックします。異なるローケルで異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
``
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message=T('must be YYYY-MM-DD HH:MM:SS!'))
``:code

以下のシンボルをフォーマット文字列に対して使用することができます(シンボルと例となる文字列を示します)：
``
        as a decimal number [00,53]. All days in a new year preceding
        the first Sunday are considered to be in week 0.
        as a decimal number [00,53]. All days in a new year preceding
        the first Monday are considered to be in week 0.
``:code

##### ``IS_DATETIME_IN_RANGE``
``IS_DATETIME_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
``
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message=T('must be YYYY-MM-DD HH:MM::SS!'))
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。

##### ``IS_DECIMAL_IN_RANGE``
``IS_DECIMAL_IN_RANGE``:inxx

``
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10))
``:code
         
入力をPythonのDecimalへと変換します。もしくは、数値が指定した範囲に収まっていない場合はエラーを生成します。比較はPythonのDecimalの算術で行われます。

最小値と最大値にはNoneを設定することができ、それぞれ。下限なし、上限なしを意味します。


##### ``IS_EMAIL``
``IS_EMAIL``:inxx

フィールドの値がemailのアドレスのようになっているかをチェックします。確認のためemailを送信することは試みません。
``
requires = IS_EMAIL(error_message=T('invalid email!'))
``:code

##### ``IS_EQUAL_TO``
``IS_EQUEL_TO``:inxx

検証された値が与えられた値(変数にすることもできます)と等しいかチェックします：
``
requires = IS_EQUAL_TO(request.vars.password,
                       error_message=T('passwords do not match'))
``:code

##### ``IS_EXPR``
``IS_EXPR``:inxx

最初の引数は、変数に値に関する論理的な表現を保持する文字列です。フィールドの値を、その式がTrueに評価されるかどうかで検証します。例:
``
requires = IS_EXPR('int(value)%3==0',
                   error_message=T('not divisible by 3'))
``:code

例外が発生しないように、初めに整数であることをチェックしたほうがよいでしょう。
``
requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]
``:code

##### ``IS_FLOAT_IN_RANGE``
``IS_FLOAT_IN_RANGE``:inxx

フィールドの値が範囲内の浮動小数点になっていることをチェックします。次の例では、0 <= value <= 100 の範囲をチェックしています：
``
requires = IS_FLOAT_IN_RANGE(0, 100,
         error_message=T('too small or too large!'))
``:code

##### ``IS_INT_IN_RANGE``
``IS_INT_IN_RANGE``:inxx

フィールドの値が範囲内の整数になっていることをチェックします。次の例では、``0 <= value <= 100``の範囲をチェックしています：

``
requires = IS_INT_IN_RANGE(0, 100,
         error_message=T('too small or too large!'))
``:code

##### ``IS_IN_SET``
``IS_IN_SET``:inxx
``multiple``:inxx

フィールドの値がセットに含まれていることをチェックします：
``
requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message=T('must be a or b or c'))
``:code

zero引数は省略可能で、デフォルトで選択されたオプション、つまり、``IS_IN_SET``バリデータ自身によって受理されないオプション、のテキストを決めます。"chooose one"オプションを望まない場合は、``zero=None``としてください。

``zero``オプションはリビジョン(1.67.1)において導入されました。これは、アプリケーションを壊さないという意味で後方互換性を破りませんでした。しかし、以前は``zero``オプションがなかったので、その挙動は変化しました。

セットの要素は常に文字列でなければなりません。ただし、このバリデータが``IS_INT_IN_RANGE``(値をintに変換)か``IS_FLOAT_RANGE``(値をfloatに変換)の後に続く場合はその限りではありません。例:
``
requires = [IS_INT_IN_RANGE(0, 8), IS_IN_SET([2, 3, 5, 7],
          error_message=T('must be prime and less than 10'))]
``:code

##### ``IS_IN_SET``とタグ付け

``IS_IN_SET``バリデータは``multiple=False``というオプション属性を持ちます。これがTrueに設定されている場合、複数の値を1つのフィールドに格納することができます。フィールドの型は、``list:integer``か``list:string``にしてください。multiple参照は、作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。

##### ``IS_LENGTH``
``IS_LENGTH``:inxx

フィールドの値の長さが与えられた境界の間に収まることをチェックします。テキストとファイルの入力の両方で機能します。

引数は次の通りです：
- maxsize: 最大許容の長さ/サイズ(デフォルトは255)
- minsize: 最小許容の長さ/サイズ

例：テキストの文字列が33文字よりも短いかをチェックします：
``
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
``:code

例：テキストの文字列が5文字よりも長いかをチェックします：
``
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
``:code

アップロードされたファイルのサイズが1KBと1MBの間にあるかをチェックします：
``
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
``:code

ファイルを除くすべてのフィールドの型に対して、値の長さをチェックします。ファイルの場合は、値は``cookie.FieldStorage``になります。したがって、直感的に予想できる挙動であるファイルのデータ長をチェックすることになります。

##### ``IS_LIST_OF``
``IS_LIST_OF``:inxx

これは適切なバリデータではありません。その使用目的は、複数の値を返すフィールドの検証を可能にすることです。フォームが同じ名前の複数のフィールドや複数選択ボックスを含む場合といった稀なケースにおいて使用されます。唯一の引数は、別のバリデータです。別のバリデータをリストの各要素に適用することしかしません。たとえば、次の式はリストの各項目が0～10の範囲にある整数であることをチェックします：
``
requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))
``:code

これは、エラーを返すことはなく、エラーメッセージも含まれません。内部のバリデータがエラーの発生を制御します。

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータは決してエラーを返しません。単に、値を小文字に変換します。
``
requires = IS_LOWER()
``:code

##### ``IS_MATCH``
``IS_MATCH``:inxx

このバリデータは、値を正規表現と照合し、一致してない場合はエラーを返します。米国の郵便番号を検証する使用例を示します：
``
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
``:code

IPv4アドレスを検証する使用例です(ただし、IS_IPV4バリデータのほうがこの目的のためにはより妥当です)：
``
requires = IS_MATCH('^\d{1,3}(\.\d{1,3}){3}$',
         error_message='not an IP address')
``:code

米国の電話番号を検証するための使用例です：
``
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
``:code

Pythonの正規表現の詳細については、公式のPythonのマニュアルを参照してください。

##### ``IS_NOT_EMPTY``
``IS_NOT_EMPTY``:inxx

このバリデータは、フィールドの値が空の文字列ではないことをチェックします。
``
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
``:code

##### ``IS_TIME``
``IS_TIME``:inxx

このバリデータは、指定したフォーマットでの有効な時間がフィールドの値に入力されていることをチェックします。
``
requires = IS_TIME(error_message=T('must be HH:MM:SS!'))
``:code

##### ``IS_URL``
``IS_URL``:inxx

次のいずれかに該当するURL文字列を拒否します：
- 文字列が空またはNone
- 文字列がURLで許可されていない文字を使用する
- 文字列がHTTP構文規則のいずれかを破る
- (指定した場合)URLのスキームが'http'か'https'でない
- (ホスト名を指定した場合)トップレベルのドメインが存在しない

(これらの規則は、RFC 2616``RFC2616``:citeに基づいています)

この関数はURLの構文をチェックすることしかしません。URLが、たとえば実際の文章を指していることや、語義的に理にかなっていことはチェックしません。この関数は、省略URL('google.ca'など)の場合、自動的にURLの前に'http://'を追加します。

mode='generic'というパラメータが使用されている場合、この関数の挙動は変化します。このときは、次のいずれかに該当するURL文字列を拒否します：
- 文字列が空またはNone
- 文字列がURLで許可されていない文字を使用する
- (指定した場合)URLのスキームが有効でない

(これらの規則は、RFC 2396``RFC2396``:citeに基づいています)

許可されたスキーマのリストはallowed_schemesパラメータを使用してカスタマイズすることができます。リストからNoneを取り除いた場合、('http'のようなスキームを欠く)省略URLは拒否されます。

デフォルトで先頭に追加されるスキーマはprepend_schemeパラメータでカスタマイズすることができます。prepend_schemeをNoneに設定した場合、先頭への追加は無効になります。それでも、解析のために先頭への追加が必要なURLは受け入れられますが、戻り値は変更されません。

IS_URLは、RFC3490``RFC3490``:citeで指定されている国際化ドメイン名(IDN)の標準と互換性があります。その結果、URLには、通常の文字列またはUnicode文字列を指定できます。URLのドメイン・コンポーネント(たとえば、google.ca)が非US-ASCII文字を含んでいる場合、ドメインは(RFC3492``RFC3492``:citeで定義された)Punycodeに変換されます。IS_URLは標準を少しだけ越えて、非US-ASCII文字がURLのパスとクエリのコンポーネントにも提示されることを許可しています。これらの非US-ASCII文字はエンコードされます。たとえば、スペースは、'％20'にエンコードされます。16進数のUnicode文字0x4e86は'%4e%86'になります。

例：
``
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'], 
                  prepend_scheme='https')
``:code

##### ``IS_SLUG``
``IS_SLUG``:inxx
``
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
``:code

``check``がTrueに設定されている場合、検証される値が(英数字と繰り返しなしのダッシュのみ許可する)スラグかどうかをチェックします。

``check``がFalseの場合(デフォルト)、入力値をスラグに変換します。

##### ``IS_STRONG``
``IS_STRONG``:inxx

フィールド(通常はパスワードフィールド)の複雑さの要求を強制します。

例：
``
requires = IS_STRONG(min=10, special=2, upper=2)
``:code

ここで、
- minは値の最小の長さです
- specialは要求される特殊文字の最小数です。特殊文字は、次のいずれかなります``@#$%^&*(){}[]-+``
- upperは大文字の最小数です

##### ``IS_IMAGE``
``IS_IMAGE``:inxx

このバリデータは、ファイル入力からアップロードされたファイルが選択した画像のフォーマットの1つで保存されているか、また、与えられた制約内の寸法(幅と高さ)を持っているかどうかをチェックします。

これは、最大ファイルサイズはチェックしていません(そのためにはIS_LENGTHを使用してください)。何もデータがアップロードされていない場合は、検証エラーを返します。BMP、GIF、JPEG、PNGのファイル形式をサポートしています。Python Imaging Libraryは必要ありません。

コードの一部は参照``source1``:citeから取っています。

次の引数を取ります：
- extensions: 許可する小文字の画像ファイル拡張子を保持する反復可能オブジェクト
- maxsize: 画像の最大の幅と高さを保持する反復可能オブジェクト
- minsize: 画像の最小の幅と高さを保持する反復可能オブジェクト

画像サイズのチェックを回避するには、minsizeとして(-1, -1)を使用してください。

いくつかの例を示します：
- アップロードされたファイルがサポートされている画像フォーマットのいずれかに含まれるかをチェックします：
``
requires = IS_IMAGE()
``:code
- アップロードされたファイルがJPEGまたはPNG形式かをチェックします：
``
requires = IS_IMAGE(extensions=('jpeg', 'png'))
``:code

- アップロードされたファイルが最大200x200ピクセルのサイズのPNGであるかをチェックします：
``
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
``:code

##### ``IS_UPLOAD_FILENAME``
``IS_UPLOAD_FILENAME``:inxx

このバリデータは、ファイル入力からアップロードされたファイルの名前と拡張子が与えられた条件に一致するかをチェックします。

どのような方法であれ、これはファイルの型を保証するものではありません。何もデータがアップロードされていない場合は、検証エラーを返します。

引数は次の通りです：
- filename: (ドットの前の)ファイル名の正規表現です。
- extension: (ドットの後の)拡張子の正規表現です。
- lastdot: どのドットがファイル名/拡張子の区分に使用されるか：``True``の場合、最後のドットとなります(たとえば、"file.tar.gz"は"file.tar"+"gz"に分解されます)。一方``False``の場合、最初のドットになります(たとえば、"file.tar.gz"は"file"+"tar.gz"に分解されます)。
- case: 0は大文字小文字を維持します。1は文字列を小文字に変換します(デフォルト)。2は文字列を大文字に変換します。

dotが存在しない場合、拡張子は空の文字列に対してチェックされ、ファイル名はすべての文字列に対してチェックされます。

例：

ファイルがpdfの拡張子を持つかをチェックします(大文字小文字は区別しません)：
``
requires = IS_UPLOAD_FILENAME(extension='pdf')
``:code

ファイルがtar.gz拡張子を持ち、かつ、backupで始まる名前を持つかをチェックします：
``
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
``:code

ファイルが、拡張子を持たず、かつ、名前がREADMEに一致するかをチェックします(大文字小文字を区別します)：
``
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
``:code

##### ``IS_IPV4``
``IS_IPV4``:inxx

このバリデータは、フィールドの値が10進数形式のIPバージョン4のアドレスかをチェックします。特定の範囲のアドレスに強制するように設定できます。

IPv4の正規表現は参照``regexlib``:citeから取っています。
引数は以下の通りです。
- ``minip``許容する最下限のアドレス。str(例：192.168.0.1)や、反復可能な数字(例：[192, 168, 0, 1])や、int(例：3232235521)を受け入れます。
- ``maxip``許容する最上限のアドレス。上と同様に受け入れます。

ここにある3つの例の値は同じです。アドレスは、次の関数で包含チェックをするために、整数に変換されるからです：
``
number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]
``:code

例：

有効なIPv4のアドレスに対するチェックをします：
``
requires = IS_IPV4()
``:code

有効なプライベートネットワークのIPv4のアドレスに対するチェックをします：
``
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
``:code

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータはエラーを返すことはありません。値を小文字に変換します。

##### ``IS_UPPER``
``IS_UPPER``:inxx

このバリデータはエラーを返すことはありません。値を大文字に変換します。
``
requires = IS_UPPER()
``:code

##### ``IS_NULL_OR``
``IS_NULL_OR``:inxx

非推奨のもので、下に記述する``IS_EMPTY_OR``の別名です。

##### ``IS_EMPTY_OR``
``IS_EMPTY_OR``:inxx

他の要求と一緒にフィールに空の値を許可したい場合があります。たとえば、フィールドは日付だが、空の値にもなりうるという場合です。``IS_EMPTY_OR``バリデータはこれを可能にします：
``
requires = IS_NULL_OR(IS_DATE())
``:code

##### ``CLEANUP``
``CLEANUP``:inxx

これはフィルタです。失敗することはありません。単に、[10、13、32〜127]のリストに含まれない10進数のASCIIコードを持つすべての文字を削除します。
``
requires = CLEANUP()
``:code

##### ``CRYPT``
``CRYPT``:inxx

これもフィルタです。入力に対して安全なハッシュを実行します。パスワードがデータベースに明白に渡されるのを防ぐのに使用されます。
``
requires = CRYPT()
``:code

keyが指定されていない場合、MD5アルゴリズムが使用されます。keyが指定されている場合、CRYPTはHMACアルゴリズムを用います。keyには、HMACとともに使用するアルゴリズムを決める接頭辞を含めることも可能です。たとえば、SHA512は次のようになります：

``
requires = CRYPT(key='sha512:thisisthekey')
``:code

これは、推奨される構文です。keyは、使用されるデータベースに関連付けられた一意の文字列でなければなりません。keyは変更することはできません。keyを失うと、それ以前にハッシュ化された値は使用できなくなります。

#### Database Validators

##### ``IS_NOT_IN_DB``
``IS_NOT_IN_DB``:inxx

次の例を考えます：
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

これは、新規のpersonを挿入したとき、彼/彼女の名前がデータベース、``db``に、すなわち、フィールド``person.name``にすでに存在していないことを要求します。他のバリデータと同様、この要求はフォーム処理のレベルで強制され、データベースレベルではされません。これには次のわずかな可能性があります。2人の訪問者が同時に、同じperson.nameを持つレコードを挿入しようとした場合、競合状態を引き起こし、両者のレコードが受け入れられてしまうことです。したがって、データベースに対しても、このフィールドが一意の値を持つということを知らせるほうが安全です：
``
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

このとき、競合状態が発生した場合、データベースはOperationalErrorを発生させ、2つのうちの1つの挿入が拒否されます。

``IS_NOT_IN_DB``の最初の引数は、データベース接続かSetにすることができます。後者の場合、Setで定義されたセットのみをチェックするようになります。

次のコードは、たとえば、互いに10日以内に同じ名前を持つ2人のpersonsの登録を許可しません：
``
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp>now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
``:code

##### ``IS_IN_DB``
``IS_IN_DB``:inxx

次のテーブルと要求を考えてください：

``
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
``:code

これは、dogの挿入/更新/削除フォームのレベルで強制されます。これは、``dog.owner``が``db``データベースの``person.id``フィールドにおいて有効なidになっていることを要求します。このバリデータのおかげで、``dog.owner``フィールドはドロップボックスによって表現されます。バリデータの3番目の引数は、ドロップボックスの内の要素を説明する文字列です。この例では、personの``%(id)s``の代わりに、personの``%(name)s``を見たいことになります。%(...)sは、各レコードに対して括弧内においてフィールドの値によって置き換えられます。

``zero``オプションは``IS_IN_SET``バリデータに対するものと非常によく似た動作をします。

フィールドの検証はしたいが、ドロップボックスを表示したくない場合、バリデータをリストの中に置いてください。

``
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
``:code

バリデータの最初の引数は``IS_NOT_IN_DB``のようにデータベース接続やDALセットも使用できます。

``_and``:inxx
場合によっては、ドロップボックスは使用したが(上のようにはリスト構文を用いたくないことになります)、追加のバリデータを使用したいときがあります。この目的のために、``IS_IN_DB``バリデータは``_and``という追加の引数をとります。これは、検証値が``IS_IN_DB``の検証を通った場合に適用される他のバリデータのリストを指します。たとえば、db内のすべてのdogのownersにおいて、あるサブセットにはないことを検証するためには次のようにします：
``
subset=db(db.person.id>100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))
``:code

##### ``IS_IN_DB``とタグ付け
``tags``:inxx
``multiple``:inxx

``IS_IN_DB``バリデータは、``multiple=False``というオプション属性を持ちます。これが``True``に設定されている場合、複数の値が1つのフィールドに保存されます。このフィールドは、第6章で説明した``list:reference``型にする必要があります。そこでは、明示的なタグ付けの例が説明されています。``multiple``の参照は作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。

#### Custom Validators
``custom validator``:inxx

すべてのバリデータは、以下のプロトタイプに従っています：
``
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
``:code

すなわち、値を検証するために呼ばれたとき、バリデータは``(x, y)``というタプルを返します。``y``が``None``の場合、値は検証を通過し、``x``は通過した値を保持します。たとえば、バリデータが値に整数であることを要求する場合、``x``は``int(value)``に変換されます。値が検証を通過しない場合は、``x``は入力値を保持し、``y``は検証の失敗を説明するエラーメッセージを保持します。このエラーメッセージは、有効でないフォームにエラーを報告するために使用されます。

バリデータは``formatter``メソッドも持つことが可能です。これは、``__call__``が行うものと逆の変換を行う必要があります。たとえば、``IS_DATE``に対するソースコードを考えてみます：
``
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
``:code

成功した場合、 ``__call__``メソッドはフォームからデータ文字列を読み取り、コンストラクタで指定したフォーマット文字列を用いてそれをdatetime.dateオブジェクトに変換します。``formatter``オブジェクトは、datetime.dateオブジェクトを受け取り、同じフォーマットを用いてそれを文字列表現に変換します。``formatter``はフォームによって自動的に呼び出されます。しかし、明示的に使用して、オブジェクトを適切な表現に変換することもできます。例:
``
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.formatter(row.birth)
01/01/2008
``:code

複数のバリデータが要求(リストに格納)されたとき、それらは順序通りに実行され、1つの出力は入力として次のものへ渡されます。この連鎖は、バリデータのいずれかが失敗したときに中断されます。

反対に、フィールドの``formatter``メソッドを呼ぶとき、複数のバリデータに関連付けられたformattersもまた連鎖されますが、逆順になります。

#### 依存関係をバリデータ

時折、フィールドを検証する必要があり、その検証が別のフィールドの値に依存することがあります。これは行うことができますが、バリデータの設定をコントローラで、他のフィールドの値を知ったときに、行う必要があります。例として、ユーザー名とパスワードを2回尋ねる登録フォームを生成するページを示します。どのフィールドも空にすることはできず、両者のパスワードは一致しなければなりません：
``
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_SAME_AS(request.vars.password)))
    if form.accepts(request.vars, session):
        pass # or take some action
    return dict(form=form)
``:code

同じメカニズムは、FORMとSQLFORMオブジェクトに適用することができます。

### Widgets

以下に利用可能なweb2pyのウィジェットの一覧を示します：
``
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
``:code

最初の10個は対応するフィールド型のデフォルトになります。"options"ウィジェットは、フィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=False``(デフォルトの挙動)のときに使用されます。"multiple"ウィジェットはフィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=True``のときに使用されます。"radio"と"checkboxes"ウィジェットはデフォルトでは決して使用されませんが、手動で設定することができます。autocompleteウィジェットは特別で、それ自身のセクションで説明します。

たとえば、textareaで表される"文字列"フィールドを持つには以下のようにします：
``
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
``:code

新しいウィジェットを作成したり、既存のウィジェットを拡張したりすることができます。

``SQLFORM.widgets[type]``はクラスで、``SQLFORM.widgets[type].widget``は対応するクラスの静的メンバ関数です。各ウィジェット関数は2つの引数をとります。フィールドオブジェクトと現在のフィールドの値です。これは、ウィジェットの表現を返します。例として、stringウィジェットは次のように再コード化することができます：
``
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
``:code

idとclassの値は、本章の後半で説明されている慣例に従う必要があります。ウィジェットは独自のバリデータを持つことが可能ですが、バリデータをフィールドの"requires"属性に関連付け、ウィジェットがそこからそれらを得るようにするのが良いプラクティスです。

#### Autocomplete Widget
``autocomplete``:inxx

autocompleteウィジェットには2つの使い道があります：リストから値を受けてフィールドを自動補完するためと、参照フィールドを自動補完するためです(ここで自動補完される文字列はidのように実装された参照の表現です)。

最初のケースは簡単です：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category')
db.product.category.widget = SQLHTML.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)
``:code

ここで、``limitby``は一度に10個までの候補しか表示しないようにウィジェットに指示します。``min_length``は、ユーザーが検索ボックスにおいて少なくとも2文字をタイプした後のみ、候補を取得するAjaxコールバックを実行するようにウィジェットに指示します。

2番目のケースはより複雑になります：
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category')
db.product.category.widget = SQLHTML.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
``:code

この場合、``id_field``の値は、自動補完される値が``db.category.name``でも、保存される値は対応する``db.category.id``になるようにウェジェットに支持します。オプションのパラメタ``orderby``は、候補をどのようにソートするかをウィジェットに指示します(デフォルトはアルファベット順です)。

このウィジェットは、Ajaxを介して動作します。ここで、Ajaxコールバックはどこにあるのでしょうか？いくつかの魔法が、このウィジェットで起こっています。コールバックはウィジェットオブジェクトのメソッドそのものです。どのように公開されているのでしょうか？web2pyにおいて、任意のコード断片はHTTP例外を発生させることによってレスポンスを生成することができます。このウィジェットは次の方法でこの可能性を利用しています：ウィジェットはAjax呼び出しを最初にウィジェットを生成したURLと同じところに送ります。そして、request.varsにおいて特別なトークンを置きます。ウィジェットは再びインスタンス化されるはずで、ウィジェットはそのトークンを見つけ、リクエストに応答するHTTP例外を発生させます。これらすべては内部で行われ、開発者に対して隠されています。
